{
  "language": "Solidity",
  "sources": {
    "contracts/accessors/NameAccessor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../interfaces/INameRegistry.sol\";\n\n/// @title NameAccessor - manages the endpoints.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract NameAccessor {\n\tINameRegistry internal _nameRegistry;\n\n\t/// @dev Sets the address of NameRegistry.\n\t/// @param nameRegistry address of the NameRegistry\n\tfunction initialize(address nameRegistry) internal {\n\t\t_nameRegistry = INameRegistry(nameRegistry);\n\t}\n\n\t/// @dev Prevents calling a function from anyone except the accepted contracts.\n\tmodifier onlyAllowedContract() {\n\t\trequire(_nameRegistry.allowedContracts(msg.sender), \"KD013\");\n\t\t_;\n\t}\n\n\t/// @dev Throws if called by any account other than the owner.\n\tmodifier onlyOwner() {\n\t\trequire(owner() == msg.sender, \"KD012\");\n\t\t_;\n\t}\n\n\t/// @dev Gets the address of NameRegistry\n\tfunction nameRegistryAddress() public view returns (address) {\n\t\treturn address(_nameRegistry);\n\t}\n\n\t/// @dev Gets the address of AdPool.\n\tfunction adPoolAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"AdPool\")));\n\t}\n\n\t/// @dev Gets the address of MediaFactory.\n\tfunction mediaFactoryAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"MediaFactory\")));\n\t}\n\n\t/// @dev Gets the address of MediaRegistry.\n\tfunction mediaRegistryAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"MediaRegistry\")));\n\t}\n\n\t/// @dev Gets the address of Vault.\n\tfunction vaultAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"Vault\")));\n\t}\n\n\t/// @dev Gets the address of EventEmitter.\n\tfunction eventEmitterAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"EventEmitter\")));\n\t}\n\n\t/// @dev Gets the address of EnglishAuction.\n\tfunction englishAuctionAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"EnglishAuction\")));\n\t}\n\n\t/// @dev Gets the address of OpenBid.\n\tfunction openBidAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"OpenBid\")));\n\t}\n\n\t/// @dev Gets the address of OfferBid.\n\tfunction offerBidAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"OfferBid\")));\n\t}\n\n\t/// @dev Gets the address of ProposalReview.\n\tfunction proposalReviewAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"ProposalReview\")));\n\t}\n\n\t/// @dev Gets the owner address.\n\tfunction owner() public view returns (address) {\n\t\treturn _nameRegistry.deployer();\n\t}\n}\n"
    },
    "contracts/interfaces/INameRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title INameRegistry - saves a set of addresses used in the system.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ninterface INameRegistry {\n\t/// @dev Sets the address associated with the key name.\n\t///      If the address is the contract, not an EOA, it is\n\t///      saved as the allowed contract list.\n\t/// @param key bytes32 of the key\n\t/// @param value address of the value\n\tfunction set(bytes32 key, address value) external;\n\n\t/// @dev Gets the address associated with the key name.\n\t/// @param key bytes32 of the key\n\tfunction get(bytes32 key) external view returns (address);\n\n\t/// @dev Returns whether or not the address is the one that we deployed.\n\t/// @param caller address of the msg.sender\n\tfunction allowedContracts(address caller) external returns (bool);\n\n\t/// @dev Gets the deployer of NameRegistry.\n\tfunction deployer() external view returns (address);\n}\n"
    },
    "contracts/proxies/MediaFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../proxies/MediaProxy.sol\";\nimport \"../accessors/NameAccessor.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\nimport \"../interfaces/IMediaRegistry.sol\";\n\n/// @title MediaFactory - creates proxy contracts for media accounts.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract MediaFactory is NameAccessor {\n\t/// @dev Emitted when a new media is created.\n\tevent CreateProxy(MediaProxy proxy);\n\n\t/// @dev Initializer\n\t/// @param _nameRegistry address of NameRegistry\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @dev Create a new account for media. Each proxy has its own storage and saves\n\t///      data related to NFTs.\n\t/// @param mediaEOA address of the media EOA\n\t/// @param applicationMetadata string of constant metadata for the defailts of the account\n\t/// @param updatableMetadata string of constant metadata for the defailts of the account\n\t/// @param initializer bytes of the initalize calldata\n\t/// @param saltNonce uint256 of the salt number to create a proxy address\n\tfunction newMedia(\n\t\taddress mediaEOA,\n\t\tstring memory applicationMetadata,\n\t\tstring memory updatableMetadata,\n\t\tbytes memory initializer,\n\t\tuint256 saltNonce\n\t) external onlyOwner returns (MediaProxy proxy) {\n\t\tproxy = createProxyWithNonce(nameRegistryAddress(), initializer, saltNonce);\n\t\t_registry().addMedia(\n\t\t\taddress(proxy),\n\t\t\tapplicationMetadata,\n\t\t\tupdatableMetadata,\n\t\t\tmediaEOA\n\t\t);\n\t\t_event().emitNewMedia(\n\t\t\taddress(proxy),\n\t\t\tmediaEOA,\n\t\t\tapplicationMetadata,\n\t\t\tupdatableMetadata,\n\t\t\tsaltNonce\n\t\t);\n\t}\n\n\t/// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n\t/// @param accessor Address of accessor contract.\n\t/// @param initializer Payload for message call sent to new proxy contract.\n\t/// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n\tfunction createProxyWithNonce(\n\t\taddress accessor,\n\t\tbytes memory initializer,\n\t\tuint256 saltNonce\n\t) internal returns (MediaProxy proxy) {\n\t\tproxy = deployProxyWithNonce(accessor, initializer, saltNonce);\n\t\tif (initializer.length > 0)\n\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\tassembly {\n\t\t\t\tif eq(\n\t\t\t\t\tcall(\n\t\t\t\t\t\tgas(),\n\t\t\t\t\t\tproxy,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tadd(initializer, 0x20),\n\t\t\t\t\t\tmload(initializer),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0\n\t\t\t\t\t),\n\t\t\t\t\t0\n\t\t\t\t) {\n\t\t\t\t\trevert(0, 0)\n\t\t\t\t}\n\t\t\t}\n\t\temit CreateProxy(proxy);\n\t}\n\n\t/// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n\t///      This method is only meant as an utility to be called from other methods\n\t/// @param accessor Address of accessor contract.\n\t/// @param initializer Payload for message call sent to new proxy contract.\n\t/// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n\tfunction deployProxyWithNonce(\n\t\taddress accessor,\n\t\tbytes memory initializer,\n\t\tuint256 saltNonce\n\t) internal returns (MediaProxy proxy) {\n\t\t// If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n\t\tbytes32 salt = keccak256(\n\t\t\tabi.encodePacked(keccak256(initializer), saltNonce)\n\t\t);\n\t\tbytes memory deploymentData = abi.encodePacked(\n\t\t\ttype(MediaProxy).creationCode,\n\t\t\tuint256(uint160(accessor))\n\t\t);\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tproxy := create2(\n\t\t\t\t0x0,\n\t\t\t\tadd(0x20, deploymentData),\n\t\t\t\tmload(deploymentData),\n\t\t\t\tsalt\n\t\t\t)\n\t\t}\n\t\trequire(address(proxy) != address(0), \"Create2 call failed\");\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _registry() internal view returns (IMediaRegistry) {\n\t\treturn IMediaRegistry(mediaRegistryAddress());\n\t}\n\n\tfunction _event() internal view returns (IEventEmitter) {\n\t\treturn IEventEmitter(eventEmitterAddress());\n\t}\n}\n"
    },
    "contracts/proxies/MediaProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./AbstractProxy.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\n\n/// @title MediaProxy - do delegatecalls to the destination contract.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract MediaProxy is AbstractProxy {\n\t/**\n\t * @dev Storage slot with the address of the current implementation.\n\t * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n\t * validated in the constructor.\n\t */\n\tbytes32 internal constant _IMPLEMENTATION_SLOT =\n\t\t0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n\t/// @dev Initializer\n\t/// @param nameRegistry address of NameRegistry\n\tconstructor(address nameRegistry) AbstractProxy(nameRegistry) {}\n\n\tfunction _implementation()\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address impl)\n\t{\n\t\treturn StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n\t}\n\n\t/**\n\t * @dev Stores a new address in the EIP1967 implementation slot.\n\t */\n\tfunction _setImplementation(address newImplementation)\n\t\tinternal\n\t\tvirtual\n\t\toverride\n\t{\n\t\trequire(\n\t\t\tAddress.isContract(newImplementation),\n\t\t\t\"ERC1967: new implementation is not a contract\"\n\t\t);\n\t\tStorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n\t}\n}\n"
    },
    "contracts/interfaces/IEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Ad.sol\";\n\n/// @title IEventEmitter - emits events.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ninterface IEventEmitter {\n\tfunction emitNewSpace(string memory metadata) external;\n\n\tfunction emitNewPeriod(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 saleStartTimestamp,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t) external;\n\n\tfunction emitDeletePeriod(uint256 tokenId) external;\n\n\tfunction emitBuy(\n\t\tuint256 tokenId,\n\t\tuint256 msgValue,\n\t\taddress msgSender,\n\t\tuint256 blockTimestamp\n\t) external;\n\n\tfunction emitBid(\n\t\tuint256 tokenId,\n\t\tuint256 msgValue,\n\t\taddress msgSender,\n\t\tuint256 blockTimestamp\n\t) external;\n\n\tfunction emitBidWithProposal(\n\t\tuint256 tokenId,\n\t\tuint256 msgValue,\n\t\taddress msgSender,\n\t\tstring memory metadata,\n\t\tuint256 blockTimestamp\n\t) external;\n\n\tfunction emitSelectProposal(\n\t\tuint256 tokenId,\n\t\tuint256 index,\n\t\taddress successfulBidder,\n\t\tstring memory reason\n\t) external;\n\n\tfunction emitReceiveToken(\n\t\tuint256 tokenId,\n\t\tuint256 price,\n\t\taddress buyer,\n\t\tuint256 blockTimestamp\n\t) external;\n\n\tfunction emitOfferPeriod(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\taddress sender,\n\t\tuint256 price\n\t) external;\n\n\tfunction emitCancelOffer(uint256 tokenId) external;\n\n\tfunction emitAcceptOffer(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tuint256 price\n\t) external;\n\n\tfunction emitWithdraw(uint256 amount) external;\n\n\tfunction emitPropose(uint256 tokenId, string memory metadata) external;\n\n\tfunction emitAcceptProposal(uint256 tokenId, string memory metadata) external;\n\n\tfunction emitDenyProposal(\n\t\tuint256 tokenId,\n\t\tstring memory metadata,\n\t\tstring memory reason,\n\t\tbool offensive\n\t) external;\n\n\tfunction emitTransferCustom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external;\n\n\tfunction emitNewMedia(\n\t\taddress proxy,\n\t\taddress mediaEOA,\n\t\tstring memory applicationMetadata,\n\t\tstring memory updatableMetadata,\n\t\tuint256 saltNonce\n\t) external;\n\n\tfunction emitUpdateMedia(\n\t\taddress proxy,\n\t\taddress mediaEOA,\n\t\tstring memory accountMetadata\n\t) external;\n\n\tfunction emitPaymentFailure(address receiver, uint256 price) external;\n\n\tfunction emitReceived(address receiver, uint256 price) external;\n}\n"
    },
    "contracts/interfaces/IMediaRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Ad.sol\";\n\n/// @title MediaRegistry - registers a list of media accounts.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ninterface IMediaRegistry {\n\tstruct Account {\n\t\taddress proxy;\n\t\taddress mediaEOA;\n\t\tstring applicationMetadata;\n\t\tstring updatableMetadata;\n\t}\n\n\t/// @dev Returns account info.\n\t/// @param proxy address of the proxy contract address\n\tfunction allAccounts(address proxy)\n\t\texternal\n\t\tview\n\t\treturns (\n\t\t\taddress,\n\t\t\taddress,\n\t\t\tstring memory,\n\t\t\tstring memory\n\t\t);\n\n\t/// @dev Adds media account.\n\t/// @param proxy address of the proxy contract\n\t/// @param applicationMetadata string of constant metadata for the defailts of the account\n\t/// @param updatableMetadata string of constant metadata for the defailts of the account\n\t/// @param mediaEOA address of the media account\n\tfunction addMedia(\n\t\taddress proxy,\n\t\tstring memory applicationMetadata,\n\t\tstring memory updatableMetadata,\n\t\taddress mediaEOA\n\t) external;\n\n\t/// @dev Updates media account.\n\t/// @param metadata string of the account metadata\n\t/// @param mediaEOA address of the media account\n\tfunction updateMedia(address mediaEOA, string memory metadata) external;\n\n\tfunction updateApplicationMetadata(address proxy, string memory metadata)\n\t\texternal;\n\n\t/// @dev Returns whether the account has created or not.\n\t/// @param proxy address of the proxy contract that represents an account.\n\tfunction created(address proxy) external view returns (bool);\n\n\t/// @dev Returns the owner of the account.\n\t/// @param proxy address of the proxy contract that represents an account.\n\tfunction ownerOf(address proxy) external view returns (address);\n}\n"
    },
    "contracts/proxies/AbstractProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./IProxy.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\nimport \"../accessors/NameRegistry.sol\";\n\n/// @title MediaProxy - do delegatecalls to the destination contract.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nabstract contract AbstractProxy is IProxy {\n\t/// @dev Initializer\n\t/// @param nameRegistry address of NameRegistry\n\tconstructor(address nameRegistry) {\n\t\trequire(nameRegistry != address(0), \"AR001\");\n\t\t_setImplementation(nameRegistry);\n\t}\n\n\t/// @dev Returns the address of the destination contract\n\tfunction masterCopy() public view returns (address) {\n\t\treturn _implementation();\n\t}\n\n\t/// @dev Calls logic on the destination contract.\n\t///      The desitination is decided by NameRegistry, which can be switched by the administrator\n\t///      if the contract has any changes.\n\tfallback() external payable {\n\t\t_fallback();\n\t}\n\n\tfunction _fallback() internal {\n\t\taddress _singleton = NameRegistry(masterCopy()).get(\n\t\t\tkeccak256(abi.encodePacked(\"MediaFacade\"))\n\t\t);\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tif eq(\n\t\t\t\tcalldataload(0),\n\t\t\t\t0xa619486e00000000000000000000000000000000000000000000000000000000\n\t\t\t) {\n\t\t\t\tmstore(0, _singleton)\n\t\t\t\treturn(0, 0x20)\n\t\t\t}\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\tlet success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\tswitch success\n\t\t\tcase 0 {\n\t\t\t\trevert(0, returndatasize())\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn(0, returndatasize())\n\t\t\t}\n\t\t}\n\t}\n\n\t/// @dev Transfers fees to Vault when receiving Ether payments.\n\treceive() external payable {\n\t\trequire(msg.value != 0, \"msg.value is zero\");\n\t\taddress _event = NameRegistry(masterCopy()).get(\n\t\t\tkeccak256(abi.encodePacked(\"EventEmitter\"))\n\t\t);\n\t\tIEventEmitter(_event).emitReceived(address(this), msg.value);\n\n\t\taddress vault = NameRegistry(masterCopy()).get(\n\t\t\tkeccak256(abi.encodePacked(\"Vault\"))\n\t\t);\n\t\t(bool success, ) = payable(vault).call{ value: msg.value / 2, gas: 10000 }(\n\t\t\t\"\"\n\t\t);\n\t\tif (!success) {\n\t\t\tIEventEmitter(_event).emitPaymentFailure(vault, msg.value / 2);\n\t\t}\n\t}\n\n\t/**\n\t * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n\t * and {_fallback} should delegate.\n\t */\n\tfunction _implementation() internal view virtual returns (address);\n\n\tfunction _setImplementation(address implementation) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/proxies/IProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\ninterface IProxy {\n\tfunction masterCopy() external view returns (address);\n}\n"
    },
    "contracts/accessors/NameRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../interfaces/INameRegistry.sol\";\n\n/// @title NameRegistry - saves a set of addresses.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract NameRegistry is INameRegistry, Ownable {\n\tusing Address for address;\n\n\t/// @inheritdoc INameRegistry\n\tmapping(address => bool) public allowedContracts;\n\tmapping(bytes32 => address) private _addressStorage;\n\n\tconstructor() Ownable() {}\n\n\t/// @inheritdoc INameRegistry\n\tfunction set(bytes32 key, address value) public onlyOwner {\n\t\t_addressStorage[key] = value;\n\t\tif (value.isContract()) {\n\t\t\tallowedContracts[value] = true;\n\t\t}\n\t}\n\n\t/// @inheritdoc INameRegistry\n\tfunction get(bytes32 key) public view returns (address) {\n\t\treturn _addressStorage[key];\n\t}\n\n\t/// @inheritdoc INameRegistry\n\tfunction deployer() public view returns (address) {\n\t\treturn owner();\n\t}\n}\n"
    },
    "contracts/libraries/Ad.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nlibrary Ad {\n\tuint256 private constant _ID_LENGTH = 100000000000000000000000000000000;\n\t// 0.RRP     : Recommended Retail Price\n\t// 1.DUTCH   : Dutch Auction\n\t// 2.ENGLISH : English Acction\n\t// 3.OFFER   : Offered by Others\n\t// 4.OPEN    : Open Bid by revealing the content\n\tenum Pricing {\n\t\tRRP,\n\t\tDUTCH,\n\t\tENGLISH,\n\t\tOFFER,\n\t\tOPEN\n\t}\n\tstruct Period {\n\t\taddress mediaProxy;\n\t\tstring spaceMetadata;\n\t\tstring tokenMetadata;\n\t\tuint256 saleStartTimestamp;\n\t\tuint256 saleEndTimestamp;\n\t\tuint256 displayStartTimestamp;\n\t\tuint256 displayEndTimestamp;\n\t\tPricing pricing;\n\t\tuint256 minPrice;\n\t\tuint256 startPrice;\n\t\tbool sold;\n\t}\n\n\tfunction id(\n\t\tstring memory metadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp\n\t) public pure returns (uint256) {\n\t\treturn\n\t\t\tuint256(\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encodePacked(metadata, displayStartTimestamp, displayEndTimestamp)\n\t\t\t\t)\n\t\t\t) % _ID_LENGTH;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/peripheries/ProposalReview.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Ad.sol\";\nimport \"../libraries/Purchase.sol\";\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"../interfaces/IProposalReview.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\nimport \"../interfaces/IEnglishAuction.sol\";\nimport \"../interfaces/IMediaRegistry.sol\";\n\ncontract ProposalReview is IProposalReview, BlockTimestamp, NameAccessor {\n\t/// @dev Maps a tokenId with the proposal content.\n\tmapping(uint256 => Proposal) public proposed;\n\n\t/// @dev Maps a tokenId with denied reasons.\n\tmapping(uint256 => Denied[]) public deniedReasons;\n\n\t/// @dev Maps a tokenId with the content metadata.\n\tmapping(uint256 => string) public accepted;\n\n\tmodifier onlyProxies() {\n\t\trequire(_mediaRegistry().ownerOf(msg.sender) != address(0x0), \"KD011\");\n\t\t_;\n\t}\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @inheritdoc IProposalReview\n\tfunction propose(\n\t\tuint256 tokenId,\n\t\tstring memory metadata,\n\t\taddress msgSender\n\t) external virtual onlyProxies {\n\t\trequire(bytes(accepted[tokenId]).length == 0, \"KD132\");\n\t\tproposed[tokenId] = Proposal(metadata, msgSender);\n\t\t_event().emitPropose(tokenId, metadata);\n\t}\n\n\t/// @inheritdoc IProposalReview\n\tfunction accept(uint256 tokenId) external virtual onlyProxies {\n\t\tstring memory metadata = proposed[tokenId].content;\n\t\trequire(bytes(metadata).length != 0, \"KD130\");\n\t\taccepted[tokenId] = metadata;\n\t\tproposed[tokenId] = Proposal(\"\", proposed[tokenId].proposer);\n\t\t_event().emitAcceptProposal(tokenId, metadata);\n\t}\n\n\t/// @inheritdoc IProposalReview\n\tfunction denyProposal(\n\t\tuint256 tokenId,\n\t\tstring memory reason,\n\t\tbool offensive\n\t) external virtual onlyProxies {\n\t\tstring memory metadata = proposed[tokenId].content;\n\t\trequire(bytes(metadata).length != 0, \"KD130\");\n\t\tdeniedReasons[tokenId].push(Denied(reason, offensive));\n\t\t_event().emitDenyProposal(tokenId, metadata, reason, offensive);\n\t}\n\n\t/// @inheritdoc IProposalReview\n\tfunction proposer(uint256 tokenId) external view returns (address) {\n\t\treturn proposed[tokenId].proposer;\n\t}\n\n\t/// @inheritdoc IProposalReview\n\tfunction acceptedContent(uint256 tokenId)\n\t\texternal\n\t\tview\n\t\treturns (string memory)\n\t{\n\t\treturn accepted[tokenId];\n\t}\n\n\tfunction _event() internal view virtual returns (IEventEmitter) {\n\t\treturn IEventEmitter(eventEmitterAddress());\n\t}\n\n\tfunction _mediaRegistry() internal view returns (IMediaRegistry) {\n\t\treturn IMediaRegistry(mediaRegistryAddress());\n\t}\n}\n"
    },
    "contracts/libraries/Purchase.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./Ad.sol\";\n\nlibrary Purchase {\n\tfunction checkBeforeBuy(Ad.Period memory period, uint256 msgValue)\n\t\tpublic\n\t\tpure\n\t{\n\t\trequire(period.pricing == Ad.Pricing.RRP, \"KD120\");\n\t\trequire(!period.sold, \"KD121\");\n\t\trequire(period.minPrice == msgValue, \"KD122\");\n\t}\n\n\tfunction checkBeforeBuyBasedOnTime(\n\t\tAd.Period memory period,\n\t\tuint256 currentPrice,\n\t\tuint256 blockTimestamp,\n\t\tuint256 msgValue\n\t) public pure {\n\t\trequire(period.pricing == Ad.Pricing.DUTCH, \"KD123\");\n\t\trequire(!period.sold, \"KD121\");\n\t\trequire(currentPrice <= msgValue, \"KD122\");\n\t\trequire(period.saleEndTimestamp >= blockTimestamp, \"KD129\");\n\t}\n\n\tfunction checkBeforeBid(\n\t\tAd.Period memory period,\n\t\tuint256 currentPrice,\n\t\tuint256 blockTimestamp,\n\t\tuint256 msgValue\n\t) public pure {\n\t\trequire(period.pricing == Ad.Pricing.ENGLISH, \"KD124\");\n\t\trequire(!period.sold, \"KD121\");\n\t\trequire(currentPrice < msgValue, \"KD122\");\n\t\trequire(period.saleEndTimestamp >= blockTimestamp, \"KD129\");\n\t}\n\n\tfunction checkBeforeBidWithProposal(\n\t\tAd.Period memory period,\n\t\tuint256 blockTimestamp,\n\t\tuint256 msgValue\n\t) public pure {\n\t\trequire(period.pricing == Ad.Pricing.OPEN, \"KD127\");\n\t\trequire(!period.sold, \"KD121\");\n\t\trequire(period.minPrice <= msgValue, \"KD122\");\n\t\trequire(period.saleEndTimestamp >= blockTimestamp, \"KD129\");\n\t}\n}\n"
    },
    "contracts/common/BlockTimestamp.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title BlockTimestamp - gets a block timestamp.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nabstract contract BlockTimestamp {\n\t/// @dev Method that exists purely to be overridden for tests\n\tfunction _blockTimestamp() internal view virtual returns (uint256) {\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "contracts/interfaces/IProposalReview.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title IProposalReview\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ninterface IProposalReview {\n\tstruct Denied {\n\t\tstring reason;\n\t\tbool offensive;\n\t}\n\tstruct Proposal {\n\t\tstring content;\n\t\taddress proposer;\n\t}\n\n\t/// @dev Proposes the metadata to the token you bought.\n\t///      Users can propose many times as long as it is accepted.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param metadata string of the proposal metadata\n\t/// @param msgSender address of the msg.sender\n\tfunction propose(\n\t\tuint256 tokenId,\n\t\tstring memory metadata,\n\t\taddress msgSender\n\t) external;\n\n\t/// @dev Accepts the proposal.\n\t/// @param tokenId uint256 of the token ID\n\tfunction accept(uint256 tokenId) external;\n\n\t/// @dev Denies the submitted proposal, mentioning what is the problem.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param reason string of the reason why it is rejected\n\t/// @param offensive bool if the content would offend somebody\n\tfunction denyProposal(\n\t\tuint256 tokenId,\n\t\tstring memory reason,\n\t\tbool offensive\n\t) external;\n\n\t/// @dev Returns the proposer of the token.\n\t/// @param tokenId uint256 of the token ID\n\tfunction proposer(uint256 tokenId) external view returns (address);\n\n\t/// @dev Returns the proposal content of the token.\n\t/// @param tokenId uint256 of the token ID\n\tfunction acceptedContent(uint256 tokenId)\n\t\texternal\n\t\tview\n\t\treturns (string memory);\n}\n"
    },
    "contracts/interfaces/IEnglishAuction.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Sale.sol\";\n\n/// @title IEnglishAuction\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ninterface IEnglishAuction {\n\t/// @dev Bids to participate in an auction.\n\t///      It is defined as an English Auction.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param sender address of the msg.sender\n\t/// @param amount uint256 of the msg.value\n\tfunction bid(\n\t\tuint256 tokenId,\n\t\taddress sender,\n\t\tuint256 amount\n\t) external returns (Sale.Bidding memory);\n\n\t/// @dev Receives the token you bidded if you are the successful bidder.\n\t/// @param tokenId uint256 of the token ID\n\tfunction receiveToken(uint256 tokenId) external returns (address, uint256);\n\n\t/// @dev Returns the current price.\n\t/// @param tokenId uint256 of the token ID\n\tfunction currentPrice(uint256 tokenId) external view returns (uint256);\n\n\tfunction bidding(uint256 tokenId) external view returns (Sale.Bidding memory);\n}\n"
    },
    "contracts/libraries/Sale.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./Ad.sol\";\n\nlibrary Sale {\n\tstruct Bidding {\n\t\tuint256 tokenId;\n\t\taddress bidder;\n\t\tuint256 price;\n\t}\n\tstruct Offer {\n\t\tstring spaceMetadata;\n\t\tuint256 displayStartTimestamp;\n\t\tuint256 displayEndTimestamp;\n\t\taddress sender;\n\t\tuint256 price;\n\t}\n\tstruct OpenBid {\n\t\tuint256 tokenId;\n\t\taddress sender;\n\t\tuint256 price;\n\t\tstring content;\n\t}\n\n\tfunction startPrice(Ad.Period memory period) public pure returns (uint256) {\n\t\tif (period.pricing == Ad.Pricing.RRP) {\n\t\t\treturn period.minPrice;\n\t\t} else if (period.pricing == Ad.Pricing.DUTCH) {\n\t\t\treturn period.minPrice * 10;\n\t\t} else if (period.pricing == Ad.Pricing.ENGLISH) {\n\t\t\treturn period.minPrice;\n\t\t} else if (period.pricing == Ad.Pricing.OFFER) {\n\t\t\treturn period.minPrice;\n\t\t} else if (period.pricing == Ad.Pricing.OPEN) {\n\t\t\treturn period.minPrice;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
    },
    "contracts/peripheries/EnglishAuction.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Ad.sol\";\nimport \"../libraries/Purchase.sol\";\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"../interfaces/IAdPool.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\nimport \"../interfaces/IEnglishAuction.sol\";\nimport \"../interfaces/IMediaRegistry.sol\";\n\ncontract EnglishAuction is IEnglishAuction, BlockTimestamp, NameAccessor {\n\t/// @dev Maps a tokenId with bidding info\n\tmapping(uint256 => Sale.Bidding) internal _bidding;\n\n\tmodifier onlyProxies() {\n\t\trequire(_mediaRegistry().ownerOf(msg.sender) != address(0x0), \"KD011\");\n\t\t_;\n\t}\n\n\tmodifier onlyAdPool() {\n\t\trequire(msg.sender == adPoolAddress(), \"KD011\");\n\t\t_;\n\t}\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @inheritdoc IEnglishAuction\n\tfunction bid(\n\t\tuint256 tokenId,\n\t\taddress sender,\n\t\tuint256 value\n\t) external virtual override onlyAdPool returns (Sale.Bidding memory prev) {\n\t\tprev = _bidding[tokenId];\n\t\t_bidding[tokenId] = Sale.Bidding(tokenId, sender, value);\n\t\t_event().emitBid(tokenId, value, sender, _blockTimestamp());\n\t}\n\n\t/// @inheritdoc IEnglishAuction\n\tfunction receiveToken(uint256 tokenId)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyAdPool\n\t\treturns (address bidder, uint256 price)\n\t{\n\t\t_checkBeforeReceiveToken(tokenId);\n\t\tbidder = _bidding[tokenId].bidder;\n\t\tprice = _bidding[tokenId].price;\n\t\tdelete _bidding[tokenId];\n\t\t_event().emitReceiveToken(tokenId, price, bidder, _blockTimestamp());\n\t}\n\n\tfunction bidding(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (Sale.Bidding memory)\n\t{\n\t\treturn _bidding[tokenId];\n\t}\n\n\t/// @inheritdoc IEnglishAuction\n\tfunction currentPrice(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _bidding[tokenId].price;\n\t}\n\n\tfunction _checkBeforeReceiveToken(uint256 tokenId)\n\t\tinternal\n\t\tview\n\t\treturns (Ad.Period memory period)\n\t{\n\t\tperiod = _adPool().allPeriods(tokenId);\n\t\trequire(period.pricing == Ad.Pricing.ENGLISH, \"KD124\");\n\t\trequire(!period.sold, \"KD121\");\n\t\trequire(period.saleEndTimestamp < _blockTimestamp(), \"KD125\");\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _adPool() internal view returns (IAdPool) {\n\t\treturn IAdPool(adPoolAddress());\n\t}\n\n\tfunction _event() internal view virtual returns (IEventEmitter) {\n\t\treturn IEventEmitter(eventEmitterAddress());\n\t}\n\n\tfunction _mediaRegistry() internal view returns (IMediaRegistry) {\n\t\treturn IMediaRegistry(mediaRegistryAddress());\n\t}\n}\n"
    },
    "contracts/interfaces/IAdPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Ad.sol\";\nimport \"../libraries/Sale.sol\";\n\n/// @title IAdPool - stores all ads accorss every space.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ninterface IAdPool {\n\tfunction allPeriods(uint256 tokenId) external view returns (Ad.Period memory);\n\n\tfunction spaced(string memory spaceMetadata) external view returns (bool);\n\n\t/// @dev Creates a new space for the media account.\n\t/// @param spaceMetadata string of the space metadata\n\tfunction addSpace(string memory spaceMetadata) external;\n\n\t/// @dev Create a new period for a space. This function requires some params\n\t///      to decide which kinds of pricing way and how much price to get started.\n\t/// @param proxy address of the media proxy\n\t/// @param spaceMetadata string of the space metadata\n\t/// @param tokenMetadata string of the token metadata\n\t/// @param saleEndTimestamp uint256 of the end timestamp for the sale\n\t/// @param displayStartTimestamp uint256 of the start timestamp for the display\n\t/// @param displayEndTimestamp uint256 of the end timestamp for the display\n\t/// @param pricing uint256 of the pricing way\n\t/// @param minPrice uint256 of the minimum price to sell it out\n\tfunction addPeriod(\n\t\taddress proxy,\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t) external returns (uint256);\n\n\t/// @dev Deletes a period and its token.\n\t///      If there is any users locking the fund for the sale, the amount would be transfered\n\t///      to the user when deleting the period.\n\t/// @param tokenId uint256 of the token ID\n\tfunction deletePeriod(uint256 tokenId) external;\n\n\t/// @dev Buys the token that is defined as the specific period on an ad space.\n\t///      The price of the token is fixed.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param msgValue uint256 of the price\n\tfunction soldByFixedPrice(uint256 tokenId, uint256 msgValue) external;\n\n\t/// @dev Buys the token that is defined as the specific period on an ad space.\n\t///      The price is decreasing as time goes by, that is defined as an Dutch Auction.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param msgValue uint256 of the price\n\tfunction soldByDutchAuction(uint256 tokenId, uint256 msgValue) external;\n\n\t/// @dev Bids to participate in an auction.\n\t///      It is defined as an English Auction.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param msgSender address of the sender\n\t/// @param msgValue uint256 of the price\n\tfunction bidByEnglishAuction(\n\t\tuint256 tokenId,\n\t\taddress msgSender,\n\t\tuint256 msgValue\n\t) external returns (Sale.Bidding memory);\n\n\t/// @dev Receives the token you bidded if you are the successful bidder.\n\t/// @param tokenId uint256 of the token ID\n\tfunction soldByEnglishAuction(uint256 tokenId)\n\t\texternal\n\t\treturns (address, uint256);\n\n\t/// @dev Bids to participate in an auction.\n\t///      It is defined as an Open Bid.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param proposalMetadata string of the metadata hash\n\t/// @param msgSender address of the sender\n\t/// @param msgValue uint256 of the price\n\tfunction bidWithProposal(\n\t\tuint256 tokenId,\n\t\tstring memory proposalMetadata,\n\t\taddress msgSender,\n\t\tuint256 msgValue\n\t) external;\n\n\t/// @dev Accepts an offer by the Media.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param tokenMetadata string of the NFT token metadata\n\t/// @param offer Sale.Offer\n\tfunction acceptOffer(\n\t\tuint256 tokenId,\n\t\tstring memory tokenMetadata,\n\t\tSale.Offer memory offer\n\t) external;\n\n\tfunction mediaProxyOf(uint256 tokenId) external view returns (address);\n\n\t/// @dev Returns tokenIds tied with the space metadata\n\t/// @param spaceMetadata string of the space metadata\n\tfunction tokenIdsOf(string memory spaceMetadata)\n\t\texternal\n\t\tview\n\t\treturns (uint256[] memory);\n\n\t/// @dev Returns the current price.\n\t/// @param tokenId uint256 of the token ID\n\tfunction currentPrice(uint256 tokenId) external view returns (uint256);\n\n\t/// @dev Displays the ad content that is approved by the media owner.\n\t/// @param spaceMetadata string of the space metadata\n\tfunction display(string memory spaceMetadata)\n\t\texternal\n\t\tview\n\t\treturns (string memory, uint256);\n}\n"
    },
    "contracts/test/MockTimeEnglishAuction.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../peripheries/EnglishAuction.sol\";\n\ncontract MockTimeEnglishAuction is EnglishAuction {\n\tuint256 public time;\n\n\tconstructor(address _nameRegistry) EnglishAuction(_nameRegistry) {}\n\n\tfunction _blockTimestamp() internal view override returns (uint256) {\n\t\treturn time;\n\t}\n\n\tfunction setTime(uint256 _time) external {\n\t\ttime = _time;\n\t}\n}\n"
    },
    "contracts/base/ERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../interfaces/IERC721Metadata.sol\";\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract ERC721 is Context, IERC721Enumerable, IERC721Metadata {\n\tusing Address for address;\n\tusing Strings for uint256;\n\n\t// Token name\n\tstring internal _name;\n\n\t// Token symbol\n\tstring internal _symbol;\n\n\t// Base URI\n\tstring internal _baseURI;\n\n\t// Token URIs\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t// Mapping from token ID to owner address\n\tmapping(uint256 => address) internal _owners;\n\n\t// Mapping owner address to token count\n\tmapping(address => uint256) internal _balances;\n\n\t// Mapping from token ID to approved address\n\tmapping(uint256 => address) internal _tokenApprovals;\n\n\t// Mapping from owner to operator approvals\n\tmapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n\t// Mapping from owner to list of owned token IDs\n\tmapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n\t// Mapping from token ID to index of the owner tokens list\n\tmapping(uint256 => uint256) private _ownedTokensIndex;\n\n\t// Array with all token ids, used for enumeration\n\tuint256[] private _allTokens;\n\n\t// Mapping from token id to position in the allTokens array\n\tmapping(uint256 => uint256) private _allTokensIndex;\n\n\t/**\n\t * @dev See {IERC165-supportsInterface}.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId)\n\t\tpublic\n\t\tpure\n\t\tvirtual\n\t\toverride(IERC165)\n\t\treturns (bool)\n\t{\n\t\treturn\n\t\t\tinterfaceId == type(IERC721).interfaceId ||\n\t\t\tinterfaceId == type(IERC721Metadata).interfaceId;\n\t}\n\n\t/**\n\t * @dev See {IERC721-balanceOf}.\n\t */\n\tfunction balanceOf(address owner)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\n\t\treturn _balances[owner];\n\t}\n\n\t/**\n\t * @dev See {IERC721-ownerOf}.\n\t */\n\tfunction ownerOf(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\taddress owner = _owners[tokenId];\n\t\trequire(owner != address(0), \"KD114\");\n\t\treturn owner;\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-name}.\n\t */\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-symbol}.\n\t */\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-tokenURI}.\n\t */\n\tfunction tokenURI(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (string memory)\n\t{\n\t\trequire(\n\t\t\t_exists(tokenId),\n\t\t\t\"ERC721Metadata: URI query for nonexistent token\"\n\t\t);\n\n\t\treturn\n\t\t\tbytes(_baseURI).length > 0\n\t\t\t\t? string(abi.encodePacked(_baseURI, _tokenURIs[tokenId]))\n\t\t\t\t: _tokenURIs[tokenId];\n\t}\n\n\t/**\n\t * @dev See {IERC721-approve}.\n\t */\n\tfunction approve(address to, uint256 tokenId) public virtual override {\n\t\taddress owner = ownerOf(tokenId);\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\n\n\t\trequire(\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n\t\t\t\"ERC721: approve caller is not owner nor approved for all\"\n\t\t);\n\n\t\t_approve(to, tokenId);\n\t}\n\n\t/**\n\t * @dev See {IERC721-getApproved}.\n\t */\n\tfunction getApproved(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\trequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n\t\treturn _tokenApprovals[tokenId];\n\t}\n\n\t/**\n\t * @dev See {IERC721-setApprovalForAll}.\n\t */\n\tfunction setApprovalForAll(address operator, bool approved)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t{\n\t\trequire(operator != _msgSender(), \"ERC721: approve to caller\");\n\n\t\t_operatorApprovals[_msgSender()][operator] = approved;\n\t\temit ApprovalForAll(_msgSender(), operator, approved);\n\t}\n\n\t/**\n\t * @dev See {IERC721-isApprovedForAll}.\n\t */\n\tfunction isApprovedForAll(address owner, address operator)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _operatorApprovals[owner][operator];\n\t}\n\n\t/**\n\t * @dev See {IERC721-transferFrom}.\n\t */\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public virtual override {\n\t\t//solhint-disable-next-line max-line-length\n\t\trequire(\n\t\t\t_isApprovedOrOwner(_msgSender(), tokenId),\n\t\t\t\"ERC721: transfer caller is not owner nor approved\"\n\t\t);\n\n\t\t_transfer(from, to, tokenId);\n\t}\n\n\t/**\n\t * @dev See {IERC721-safeTransferFrom}.\n\t */\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public virtual override {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev See {IERC721-safeTransferFrom}.\n\t */\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) public virtual override {\n\t\trequire(\n\t\t\t_isApprovedOrOwner(_msgSender(), tokenId),\n\t\t\t\"ERC721: transfer caller is not owner nor approved\"\n\t\t);\n\t\t_safeTransfer(from, to, tokenId, _data);\n\t}\n\n\t/**\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n\t *\n\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n\t *\n\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n\t * implement alternative mechanisms to perform token transfer, such as signature-based.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _safeTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) internal virtual {\n\t\t_transfer(from, to, tokenId);\n\t\trequire(\n\t\t\t_checkOnERC721Received(from, to, tokenId, _data),\n\t\t\t\"ERC721: transfer to non ERC721Receiver implementer\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns whether `tokenId` exists.\n\t *\n\t * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n\t *\n\t * Tokens start existing when they are minted (`_mint`),\n\t * and stop existing when they are burned (`_burn`).\n\t */\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\n\t\treturn _owners[tokenId] != address(0);\n\t}\n\n\t/**\n\t * @dev Returns whether `spender` is allowed to manage `tokenId`.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\trequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n\t\taddress owner = ownerOf(tokenId);\n\t\treturn (spender == owner ||\n\t\t\tgetApproved(tokenId) == spender ||\n\t\t\tisApprovedForAll(owner, spender));\n\t}\n\n\t/**\n\t * @dev Safely mints `tokenId` and transfers it to `to`.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must not exist.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\n\t\t_safeMint(to, tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n\t * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n\t */\n\tfunction _safeMint(\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) internal virtual {\n\t\t_mint(to, tokenId);\n\t\trequire(\n\t\t\t_checkOnERC721Received(address(0), to, tokenId, _data),\n\t\t\t\"ERC721: transfer to non ERC721Receiver implementer\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Mints `tokenId` and transfers it to `to`.\n\t *\n\t * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must not exist.\n\t * - `to` cannot be the zero address.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\n\t\trequire(!_exists(tokenId), \"ERC721: token already minted\");\n\n\t\t_beforeTokenTransfer(address(0), to, tokenId);\n\n\t\t_balances[to] += 1;\n\t\t_owners[tokenId] = to;\n\n\t\temit Transfer(address(0), to, tokenId);\n\t}\n\n\t/**\n\t * @dev Destroys `tokenId`.\n\t * The approval is cleared when the token is burned.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _burn(uint256 tokenId) internal virtual {\n\t\taddress owner = ownerOf(tokenId);\n\n\t\t_beforeTokenTransfer(owner, address(0), tokenId);\n\n\t\t// Clear approvals\n\t\t_approve(address(0), tokenId);\n\n\t\t_balances[owner] -= 1;\n\t\tdelete _owners[tokenId];\n\n\t\temit Transfer(owner, address(0), tokenId);\n\t}\n\n\t/**\n\t * @dev Transfers `tokenId` from `from` to `to`.\n\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n\t *\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must be owned by `from`.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _transfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal virtual {\n\t\trequire(\n\t\t\townerOf(tokenId) == from,\n\t\t\t\"ERC721: transfer of token that is not own\"\n\t\t);\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(from, to, tokenId);\n\n\t\t// Clear approvals from the previous owner\n\t\t_approve(address(0), tokenId);\n\n\t\t_balances[from] -= 1;\n\t\t_balances[to] += 1;\n\t\t_owners[tokenId] = to;\n\n\t\temit Transfer(from, to, tokenId);\n\t}\n\n\t/**\n\t * @dev Approve `to` to operate on `tokenId`\n\t *\n\t * Emits a {Approval} event.\n\t */\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\n\t\t_tokenApprovals[tokenId] = to;\n\t\temit Approval(ownerOf(tokenId), to, tokenId);\n\t}\n\n\t/**\n\t * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n\t * The call is not executed if the target address is not a contract.\n\t *\n\t * @param from address representing the previous owner of the given token ID\n\t * @param to target address that will receive the tokens\n\t * @param tokenId uint256 ID of the token to be transferred\n\t * @param _data bytes optional data to send along with the call\n\t * @return bool whether the call correctly returned the expected magic value\n\t */\n\tfunction _checkOnERC721Received(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) private returns (bool) {\n\t\tif (to.isContract()) {\n\t\t\ttry\n\t\t\t\tIERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)\n\t\t\treturns (bytes4 retval) {\n\t\t\t\treturn retval == IERC721Receiver(to).onERC721Received.selector;\n\t\t\t} catch (bytes memory reason) {\n\t\t\t\tif (reason.length == 0) {\n\t\t\t\t\trevert(\"ERC721: transfer to non ERC721Receiver implementer\");\n\t\t\t\t} else {\n\t\t\t\t\tassembly {\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Hook that is called before any token transfer. This includes minting\n\t * and burning.\n\t *\n\t * Calling conditions:\n\t *\n\t * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n\t * transferred to `to`.\n\t * - When `from` is zero, `tokenId` will be minted for `to`.\n\t * - When `to` is zero, ``from``'s `tokenId` will be burned.\n\t * - `from` and `to` are never both zero.\n\t *\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\t */\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal {\n\t\tif (from == address(0)) {\n\t\t\t_addTokenToAllTokensEnumeration(tokenId);\n\t\t} else if (from != to) {\n\t\t\t_removeTokenFromOwnerEnumeration(from, tokenId);\n\t\t}\n\t\tif (to == address(0)) {\n\t\t\t_removeTokenFromAllTokensEnumeration(tokenId);\n\t\t} else if (to != from) {\n\t\t\t_addTokenToOwnerEnumeration(to, tokenId);\n\t\t}\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n\t */\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(\n\t\t\tindex < balanceOf(owner),\n\t\t\t\"ERC721Enumerable: owner index out of bounds\"\n\t\t);\n\t\treturn _ownedTokens[owner][index];\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-totalSupply}.\n\t */\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _allTokens.length;\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-tokenByIndex}.\n\t */\n\tfunction tokenByIndex(uint256 index)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(\n\t\t\tindex < totalSupply(),\n\t\t\t\"ERC721Enumerable: global index out of bounds\"\n\t\t);\n\t\treturn _allTokens[index];\n\t}\n\n\t/**\n\t * @dev Private function to add a token to this extension's ownership-tracking data structures.\n\t * @param to address representing the new owner of the given token ID\n\t * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n\t */\n\tfunction _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n\t\tuint256 length = balanceOf(to);\n\t\t_ownedTokens[to][length] = tokenId;\n\t\t_ownedTokensIndex[tokenId] = length;\n\t}\n\n\t/**\n\t * @dev Private function to add a token to this extension's token tracking data structures.\n\t * @param tokenId uint256 ID of the token to be added to the tokens list\n\t */\n\tfunction _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n\t\t_allTokensIndex[tokenId] = _allTokens.length;\n\t\t_allTokens.push(tokenId);\n\t}\n\n\t/**\n\t * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n\t * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n\t * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n\t * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n\t * @param from address representing the previous owner of the given token ID\n\t * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\t */\n\tfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n\t\tprivate\n\t{\n\t\t// To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n\t\t// then delete the last slot (swap and pop).\n\n\t\tuint256 lastTokenIndex = balanceOf(from) - 1;\n\t\tuint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n\t\t// When the token to delete is the last token, the swap operation is unnecessary\n\t\tif (tokenIndex != lastTokenIndex) {\n\t\t\tuint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n\t\t\t_ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n\t\t\t_ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\t\t}\n\n\t\t// This also deletes the contents at the last position of the array\n\t\tdelete _ownedTokensIndex[tokenId];\n\t\tdelete _ownedTokens[from][lastTokenIndex];\n\t}\n\n\t/**\n\t * @dev Private function to remove a token from this extension's token tracking data structures.\n\t * This has O(1) time complexity, but alters the order of the _allTokens array.\n\t * @param tokenId uint256 ID of the token to be removed from the tokens list\n\t */\n\tfunction _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n\t\t// To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n\t\t// then delete the last slot (swap and pop).\n\n\t\tuint256 lastTokenIndex = _allTokens.length - 1;\n\t\tuint256 tokenIndex = _allTokensIndex[tokenId];\n\n\t\t// When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n\t\t// rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n\t\t// an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n\t\tuint256 lastTokenId = _allTokens[lastTokenIndex];\n\n\t\t_allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n\t\t_allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n\t\t// This also deletes the contents at the last position of the array\n\t\tdelete _allTokensIndex[tokenId];\n\t\t_allTokens.pop();\n\t}\n}\n"
    },
    "contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\t/**\n\t * @dev Returns the token collection name.\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the token collection symbol.\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n\t */\n\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n\t/**\n\t * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n\t * by `operator` from `from`, this function is called.\n\t *\n\t * It must return its Solidity selector to confirm the token transfer.\n\t * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n\t *\n\t * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n\t */\n\tfunction onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes calldata data\n\t) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\t/**\n\t * @dev Returns the total amount of tokens stored by the contract.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n\t * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n\t */\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index)\n\t\texternal\n\t\tview\n\t\treturns (uint256 tokenId);\n\n\t/**\n\t * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n\t * Use along with {totalSupply} to enumerate all tokens.\n\t */\n\tfunction tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n\t/**\n\t * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n\t */\n\tevent Transfer(\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\tuint256 indexed tokenId\n\t);\n\n\t/**\n\t * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n\t */\n\tevent Approval(\n\t\taddress indexed owner,\n\t\taddress indexed approved,\n\t\tuint256 indexed tokenId\n\t);\n\n\t/**\n\t * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n\t */\n\tevent ApprovalForAll(\n\t\taddress indexed owner,\n\t\taddress indexed operator,\n\t\tbool approved\n\t);\n\n\t/**\n\t * @dev Returns the number of tokens in ``owner``'s account.\n\t */\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\n\t/**\n\t * @dev Returns the owner of the `tokenId` token.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\n\n\t/**\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external;\n\n\t/**\n\t * @dev Transfers `tokenId` token from `from` to `to`.\n\t *\n\t * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must be owned by `from`.\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external;\n\n\t/**\n\t * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n\t * The approval is cleared when the token is transferred.\n\t *\n\t * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n\t *\n\t * Requirements:\n\t *\n\t * - The caller must own the token or be an approved operator.\n\t * - `tokenId` must exist.\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address to, uint256 tokenId) external;\n\n\t/**\n\t * @dev Returns the account approved for `tokenId` token.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction getApproved(uint256 tokenId)\n\t\texternal\n\t\tview\n\t\treturns (address operator);\n\n\t/**\n\t * @dev Approve or remove `operator` as an operator for the caller.\n\t * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n\t *\n\t * Requirements:\n\t *\n\t * - The `operator` cannot be the caller.\n\t *\n\t * Emits an {ApprovalForAll} event.\n\t */\n\tfunction setApprovalForAll(address operator, bool _approved) external;\n\n\t/**\n\t * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n\t *\n\t * See {setApprovalForAll}\n\t */\n\tfunction isApprovedForAll(address owner, address operator)\n\t\texternal\n\t\tview\n\t\treturns (bool);\n\n\t/**\n\t * @dev Safely transfers `tokenId` token from `from` to `to`.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes calldata data\n\t) external;\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n\t/**\n\t * @dev Returns true if this contract implements the interface defined by\n\t * `interfaceId`. See the corresponding\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n\t * to learn more about how these ids are created.\n\t *\n\t * This function call must use less than 30 000 gas.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/MediaFacade.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./base/ERC721.sol\";\nimport \"./base/Storage.sol\";\nimport \"./libraries/Sale.sol\";\nimport \"./common/BlockTimestamp.sol\";\nimport \"./accessors/NameAccessor.sol\";\nimport \"./interfaces/IMediaRegistry.sol\";\nimport \"./interfaces/IAdPool.sol\";\nimport \"./interfaces/IEnglishAuction.sol\";\nimport \"./interfaces/IEventEmitter.sol\";\nimport \"./interfaces/IOpenBid.sol\";\nimport \"./interfaces/IOfferBid.sol\";\nimport \"./interfaces/IProposalReview.sol\";\n\n/// @title MediaFacade - A root contract that calls the processes of each media.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract MediaFacade is\n\tERC721,\n\tReentrancyGuard,\n\tNameAccessor,\n\tBlockTimestamp,\n\tStorage\n{\n\t/// @dev Can call it by only the media\n\tmodifier onlyMedia() {\n\t\trequire(_mediaRegistry().ownerOf(address(this)) == msg.sender, \"KD012\");\n\t\t_;\n\t}\n\n\t/// @dev Prevents the media from calling by yourself\n\tmodifier exceptMedia() {\n\t\trequire(_mediaRegistry().ownerOf(address(this)) != msg.sender, \"KD014\");\n\t\t_;\n\t}\n\n\t/// @dev Called by the successful bidder\n\tmodifier onlySuccessfulBidder(uint256 tokenId) {\n\t\trequire(_english().bidding(tokenId).bidder == msg.sender, \"KD126\");\n\t\t_;\n\t}\n\n\t/// @dev Can call it only once\n\tmodifier initializer() {\n\t\trequire(address(_nameRegistry) == address(0x0), \"AR000\");\n\t\t_;\n\t}\n\n\t/// @dev Initialize the instance.\n\t/// @param title string of the title of the instance\n\t/// @param baseURI string of the base URI\n\t/// @param tokenMetadata string of the token metadata\n\t/// @param mediaEOA address of the media owner\n\t/// @param nameRegistry address of NameRegistry\n\tfunction initialize(\n\t\tstring memory title,\n\t\tstring memory baseURI,\n\t\tstring memory tokenMetadata,\n\t\taddress mediaEOA,\n\t\taddress nameRegistry\n\t) external virtual initializer {\n\t\t_name = title;\n\t\t_symbol = string(abi.encodePacked(\"Kaleido_\", title));\n\t\t_baseURI = baseURI;\n\t\t_mintRight(mediaEOA, 0, tokenMetadata);\n\t\tinitialize(nameRegistry);\n\t}\n\n\t/// @dev Updates the media EOA and the metadata.\n\t/// @param newMediaEOA address of a new EOA\n\t/// @param newMetadata string of a new metadata\n\tfunction updateMedia(address newMediaEOA, string memory newMetadata)\n\t\texternal\n\t\tvirtual\n\t\tonlyMedia\n\t{\n\t\t_mediaRegistry().updateMedia(newMediaEOA, newMetadata);\n\t}\n\n\t/// @dev Creates a new space for the media account.\n\t/// @param spaceMetadata string of the space metadata\n\tfunction newSpace(string memory spaceMetadata) external virtual onlyMedia {\n\t\t_adPool().addSpace(spaceMetadata);\n\t}\n\n\t/// @dev Create a new period for a space. This function requires some params\n\t///      to decide which kinds of pricing way and how much price to get started.\n\t/// @param spaceMetadata string of the space metadata\n\t/// @param tokenMetadata string of the token metadata\n\t/// @param saleEndTimestamp uint256 of the end timestamp for the sale\n\t/// @param displayStartTimestamp uint256 of the start timestamp for the display\n\t/// @param displayEndTimestamp uint256 of the end timestamp for the display\n\t/// @param pricing uint256 of the pricing way\n\t/// @param minPrice uint256 of the minimum price to sell it out\n\tfunction newPeriod(\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t) external virtual onlyMedia {\n\t\tuint256 tokenId = _adPool().addPeriod(\n\t\t\taddress(this),\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\tsaleEndTimestamp,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tpricing,\n\t\t\tminPrice\n\t\t);\n\t\t_mintRight(address(this), tokenId, tokenMetadata);\n\t}\n\n\t/// @dev Deletes a period and its token.\n\t///      If there is any users locking the fund for the sale, the amount would be transfered\n\t///      to the user when deleting the period.\n\t/// @param tokenId uint256 of the token ID\n\tfunction deletePeriod(uint256 tokenId) external virtual onlyMedia {\n\t\trequire(ownerOf(tokenId) == address(this), \"KD121\");\n\t\t_adPool().deletePeriod(tokenId);\n\t\t_burnRight(tokenId);\n\t}\n\n\t/// @dev Buys the token that is defined as the specific period on an ad space.\n\t///      The price of the token is fixed.\n\t/// @param tokenId uint256 of the token ID\n\tfunction buy(uint256 tokenId) external payable virtual exceptMedia {\n\t\t_adPool().soldByFixedPrice(tokenId, msg.value);\n\t\t_dropRight(msg.sender, tokenId);\n\t\t_collectFees(msg.value / 10);\n\t\t_event().emitBuy(tokenId, msg.value, msg.sender, _blockTimestamp());\n\t}\n\n\t/// @dev Buys the token that is defined as the specific period on an ad space.\n\t///      The price is decreasing as time goes by, that is defined as an Dutch Auction.\n\t/// @param tokenId uint256 of the token ID\n\tfunction buyBasedOnTime(uint256 tokenId)\n\t\texternal\n\t\tpayable\n\t\tvirtual\n\t\texceptMedia\n\t{\n\t\t_adPool().soldByDutchAuction(tokenId, msg.value);\n\t\t_dropRight(msg.sender, tokenId);\n\t\t_collectFees(msg.value / 10);\n\t\t_event().emitBuy(tokenId, msg.value, msg.sender, _blockTimestamp());\n\t}\n\n\t/// @dev Bids to participate in an auction.\n\t///      It is defined as an English Auction.\n\t/// @param tokenId uint256 of the token ID\n\tfunction bid(uint256 tokenId)\n\t\texternal\n\t\tpayable\n\t\tvirtual\n\t\texceptMedia\n\t\tnonReentrant\n\t{\n\t\tSale.Bidding memory prev = _adPool().bidByEnglishAuction(\n\t\t\ttokenId,\n\t\t\tmsg.sender,\n\t\t\tmsg.value\n\t\t);\n\t\t_refundBiddingAmount(prev);\n\t\t_processingTotal += (msg.value - prev.price);\n\t}\n\n\t/// @dev Bids to participate in an auction.\n\t///      It is defined as an Open Bid.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param proposalMetadata string of the metadata hash\n\tfunction bidWithProposal(uint256 tokenId, string memory proposalMetadata)\n\t\texternal\n\t\tpayable\n\t\tvirtual\n\t\texceptMedia\n\t{\n\t\t_adPool().bidWithProposal(tokenId, proposalMetadata, msg.sender, msg.value);\n\t\t_processingTotal += msg.value;\n\t}\n\n\t/// @dev Selects the best proposal bidded with.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param index uint256 of the index number\n\t/// @param reason string of the reason or metadata\n\tfunction selectProposal(\n\t\tuint256 tokenId,\n\t\tuint256 index,\n\t\tstring memory reason\n\t) external virtual onlyMedia nonReentrant {\n\t\t(\n\t\t\tSale.OpenBid memory selected,\n\t\t\tSale.OpenBid[] memory nonSelected\n\t\t) = _openBid().selectProposal(tokenId, index, reason);\n\t\t_dropRight(selected.sender, tokenId);\n\t\t_processingTotal -= selected.price;\n\t\t_collectFees(selected.price / 10);\n\t\t_refundToProposers(nonSelected);\n\t}\n\n\t/// @dev Receives the token you bidded if you are the successful bidder.\n\t/// @param tokenId uint256 of the token ID\n\tfunction receiveToken(uint256 tokenId)\n\t\texternal\n\t\tvirtual\n\t\tonlySuccessfulBidder(tokenId)\n\t{\n\t\t_toSuccessfulBidder(tokenId, msg.sender);\n\t}\n\n\t/// @dev Receives the token you bidded if you are the successful bidder.\n\t/// @param tokenId uint256 of the token ID\n\tfunction pushToSuccessfulBidder(uint256 tokenId) external virtual onlyMedia {\n\t\t_toSuccessfulBidder(tokenId, _english().bidding(tokenId).bidder);\n\t}\n\n\t/// @dev Offers to buy a period that the sender requests.\n\t/// @param spaceMetadata string of the space metadata\n\t/// @param displayStartTimestamp uint256 of the start timestamp for the display\n\t/// @param displayEndTimestamp uint256 of the end timestamp for the display\n\tfunction offerPeriod(\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp\n\t) external payable virtual exceptMedia {\n\t\t_offerBid().offer(\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tmsg.sender,\n\t\t\tmsg.value\n\t\t);\n\t\t_processingTotal += msg.value;\n\t}\n\n\t/// @dev Cancels an offer.\n\t/// @param tokenId uint256 of the token ID\n\tfunction cancelOffer(uint256 tokenId)\n\t\texternal\n\t\tvirtual\n\t\texceptMedia\n\t\tnonReentrant\n\t{\n\t\tSale.Offer memory prev = _offerBid().cancel(tokenId, msg.sender);\n\t\t_refundOfferedAmount(prev);\n\t\t_processingTotal -= prev.price;\n\t}\n\n\t/// @dev Accepts an offer by the Media.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param tokenMetadata string of the NFT token metadata\n\tfunction acceptOffer(uint256 tokenId, string memory tokenMetadata)\n\t\texternal\n\t\tvirtual\n\t\tonlyMedia\n\t{\n\t\tSale.Offer memory target = _offerBid().accept(tokenId);\n\t\t_adPool().acceptOffer(tokenId, tokenMetadata, target);\n\t\t_mintRight(target.sender, tokenId, tokenMetadata);\n\t\t_collectFees(target.price / 10);\n\t\t_processingTotal -= target.price;\n\t}\n\n\t/// @dev Withdraws the fund deposited to the proxy contract.\n\tfunction withdraw() external virtual onlyMedia {\n\t\tuint256 withdrawal = withdrawalAmount();\n\t\tbool success = _pay(msg.sender, withdrawal);\n\t\tif (success) _event().emitWithdraw(withdrawal);\n\t}\n\n\t/// @dev Proposes the metadata to the token you bought.\n\t///      Users can propose many times as long as it is accepted.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param metadata string of the proposal metadata\n\tfunction propose(uint256 tokenId, string memory metadata) external virtual {\n\t\trequire(ownerOf(tokenId) == msg.sender, \"KD012\");\n\t\t_review().propose(tokenId, metadata, msg.sender);\n\t}\n\n\t/// @dev Accepts the proposal.\n\t/// @param tokenId uint256 of the token ID\n\tfunction acceptProposal(uint256 tokenId) external virtual onlyMedia {\n\t\trequire(ownerOf(tokenId) == _review().proposer(tokenId), \"KD131\");\n\t\t_review().accept(tokenId);\n\t}\n\n\t/// @dev Denies the submitted proposal, mentioning what is the problem.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param reason string of the reason why it is rejected\n\t/// @param offensive bool if the content would offend somebody\n\tfunction denyProposal(\n\t\tuint256 tokenId,\n\t\tstring memory reason,\n\t\tbool offensive\n\t) external virtual onlyMedia {\n\t\t_review().denyProposal(tokenId, reason, offensive);\n\t}\n\n\t/// @dev Overrides transferFrom to emit an event from the common emitter.\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public virtual override {\n\t\tsuper.transferFrom(from, to, tokenId);\n\t\t_event().emitTransferCustom(from, to, tokenId);\n\t}\n\n\t/// @dev Overrides transferFrom to emit an event from the common emitter.\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public virtual override {\n\t\tsuper.safeTransferFrom(from, to, tokenId);\n\t\t_event().emitTransferCustom(from, to, tokenId);\n\t}\n\n\t/// @dev Returns ID based on the space metadata, display start timestamp, and\n\t///      display end timestamp. These three makes it the unique.\n\t/// @param spaceMetadata uint256 of the space metadata\n\t/// @param displayStartTimestamp uint256 of the start timestamp for the display\n\t/// @param displayEndTimestamp uint256 of the end timestamp for the display\n\tfunction adId(\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp\n\t) public pure virtual returns (uint256) {\n\t\treturn Ad.id(spaceMetadata, displayStartTimestamp, displayEndTimestamp);\n\t}\n\n\t/// @dev Returns the balacne deposited on the proxy contract.\n\tfunction balance() public view virtual returns (uint256) {\n\t\treturn address(this).balance;\n\t}\n\n\t/// @dev Returns the withdrawal amount.\n\tfunction withdrawalAmount() public view virtual returns (uint256) {\n\t\treturn address(this).balance - _processingTotal;\n\t}\n\n\tfunction _mintRight(\n\t\taddress reciever,\n\t\tuint256 tokenId,\n\t\tstring memory metadata\n\t) internal virtual {\n\t\t_mint(reciever, tokenId);\n\t\t_tokenURIs[tokenId] = metadata;\n\t\tif (tokenId != 0)\n\t\t\t_event().emitTransferCustom(address(0), reciever, tokenId);\n\t}\n\n\tfunction _burnRight(uint256 tokenId) internal virtual {\n\t\t_burn(tokenId);\n\t\t_tokenURIs[tokenId] = \"\";\n\t\t_event().emitTransferCustom(address(this), address(0), tokenId);\n\t}\n\n\tfunction _dropRight(address receiver, uint256 tokenId) internal virtual {\n\t\t_transfer(address(this), receiver, tokenId);\n\t\t_event().emitTransferCustom(address(this), receiver, tokenId);\n\t}\n\n\tfunction _refundBiddingAmount(Sale.Bidding memory prev) internal virtual {\n\t\t_pay(prev.bidder, prev.price);\n\t}\n\n\tfunction _refundOfferedAmount(Sale.Offer memory prev) internal virtual {\n\t\t_pay(prev.sender, prev.price);\n\t}\n\n\tfunction _refundToProposers(Sale.OpenBid[] memory nonSelected)\n\t\tinternal\n\t\tvirtual\n\t{\n\t\tfor (uint256 i = 0; i < nonSelected.length; i++) {\n\t\t\tSale.OpenBid memory target = nonSelected[i];\n\t\t\tif (target.price != 0) {\n\t\t\t\t_processingTotal -= target.price;\n\t\t\t\t_pay(target.sender, target.price);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _pay(address receiver, uint256 price)\n\t\tinternal\n\t\tvirtual\n\t\treturns (bool success)\n\t{\n\t\t(success, ) = payable(receiver).call{ value: price, gas: 10000 }(\"\");\n\t\tif (!success) {\n\t\t\t_event().emitPaymentFailure(receiver, price);\n\t\t}\n\t}\n\n\tfunction _toSuccessfulBidder(uint256 tokenId, address receiver)\n\t\tinternal\n\t\tvirtual\n\t{\n\t\t(, uint256 price) = _adPool().soldByEnglishAuction(tokenId);\n\t\t_processingTotal -= price;\n\t\t_dropRight(receiver, tokenId);\n\t\t_collectFees(price / 10);\n\t}\n\n\tfunction _collectFees(uint256 value) internal virtual {\n\t\t_pay(vaultAddress(), value);\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _mediaRegistry() internal view virtual returns (IMediaRegistry) {\n\t\treturn IMediaRegistry(mediaRegistryAddress());\n\t}\n\n\tfunction _adPool() internal view virtual returns (IAdPool) {\n\t\treturn IAdPool(adPoolAddress());\n\t}\n\n\tfunction _event() internal view virtual returns (IEventEmitter) {\n\t\treturn IEventEmitter(eventEmitterAddress());\n\t}\n\n\tfunction _english() internal view virtual returns (IEnglishAuction) {\n\t\treturn IEnglishAuction(englishAuctionAddress());\n\t}\n\n\tfunction _openBid() internal view virtual returns (IOpenBid) {\n\t\treturn IOpenBid(openBidAddress());\n\t}\n\n\tfunction _offerBid() internal view virtual returns (IOfferBid) {\n\t\treturn IOfferBid(offerBidAddress());\n\t}\n\n\tfunction _review() internal view virtual returns (IProposalReview) {\n\t\treturn IProposalReview(proposalReviewAddress());\n\t}\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/base/Storage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title Storage - saves state values. Note that the order of the state values\n///                  should not be reordered when upgrading because the slot would be shifted.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nabstract contract Storage {\n\t/// @dev Temporal amount that is deposited by bid or offered.\n\tuint256 internal _processingTotal;\n}\n"
    },
    "contracts/interfaces/IOpenBid.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Sale.sol\";\n\n/// @title IOpenBid\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ninterface IOpenBid {\n\t/// @dev Bids to participate in an auction.\n\t///      It is defined as an Open Bid.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param proposal string of the metadata hash\n\t/// @param sender address of the msg.sender\n\t/// @param amount uint256 of the msg.value\n\tfunction bid(\n\t\tuint256 tokenId,\n\t\tstring memory proposal,\n\t\taddress sender,\n\t\tuint256 amount\n\t) external;\n\n\t/// @dev Selects the best proposal bidded with.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param index uint256 of the index number\n\t/// @param reason string of the reason or metadata\n\tfunction selectProposal(\n\t\tuint256 tokenId,\n\t\tuint256 index,\n\t\tstring memory reason\n\t)\n\t\texternal\n\t\treturns (Sale.OpenBid memory selected, Sale.OpenBid[] memory nonSelected);\n\n\tfunction biddingList(uint256 tokenId)\n\t\texternal\n\t\tview\n\t\treturns (Sale.OpenBid[] memory);\n\n\tfunction bidding(uint256 tokenId, uint256 index)\n\t\texternal\n\t\tview\n\t\treturns (Sale.OpenBid memory);\n}\n"
    },
    "contracts/interfaces/IOfferBid.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Sale.sol\";\n\n/// @title IOfferBid\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ninterface IOfferBid {\n\t/// @dev Offers to buy a period that the sender requests.\n\t/// @param spaceMetadata string of the space metadata\n\t/// @param displayStartTimestamp uint256 of the start timestamp for the display\n\t/// @param displayEndTimestamp uint256 of the end timestamp for the display\n\t/// @param sender address of the msg.sender\n\t/// @param value uint256 of the msg.value\n\tfunction offer(\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\taddress sender,\n\t\tuint256 value\n\t) external returns (uint256);\n\n\t/// @dev Cancels an offer.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param sender address of the msg.sender\n\tfunction cancel(uint256 tokenId, address sender)\n\t\texternal\n\t\treturns (Sale.Offer memory);\n\n\t/// @dev Accepts an offer by the Media.\n\t/// @param tokenId uint256 of the token ID\n\tfunction accept(uint256 tokenId) external returns (Sale.Offer memory);\n\n\t/// @dev Returns the current price.\n\t/// @param tokenId uint256 of the token ID\n\tfunction currentPrice(uint256 tokenId) external view returns (uint256);\n\n\tfunction offered(uint256 tokenId) external view returns (Sale.Offer memory);\n}\n"
    },
    "contracts/test/MockTimeMediaFacade.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../MediaFacade.sol\";\n\ncontract MockTimeMediaFacade is MediaFacade {\n\tuint256 public time;\n\n\tfunction _blockTimestamp() internal view override returns (uint256) {\n\t\treturn time;\n\t}\n\n\tfunction setTime(uint256 _time) external {\n\t\ttime = _time;\n\t}\n}\n"
    },
    "contracts/test/MediaFacadeV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../MediaFacade.sol\";\n\ncontract MediaFacadeV2 is MediaFacade {\n\tstring public spaceDataV2;\n\tuint256 public time;\n\n\tfunction newSpace(string memory spaceMetadata)\n\t\texternal\n\t\tvirtual\n\t\toverride\n\t\tonlyMedia\n\t{\n\t\t_adPool().addSpace(spaceMetadata);\n\t\tspaceDataV2 = \"additional state\";\n\t}\n\n\tfunction getAdditional() public view returns (string memory) {\n\t\treturn spaceDataV2;\n\t}\n\n\tfunction _blockTimestamp() internal view override returns (uint256) {\n\t\treturn time;\n\t}\n\n\tfunction setTime(uint256 _time) external {\n\t\ttime = _time;\n\t}\n}\n"
    },
    "contracts/peripheries/AdPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"../interfaces/IAdPool.sol\";\nimport \"../interfaces/IMediaRegistry.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\nimport \"../interfaces/IOfferBid.sol\";\nimport \"../interfaces/IEnglishAuction.sol\";\nimport \"../interfaces/IProposalReview.sol\";\nimport \"../interfaces/IOpenBid.sol\";\nimport \"../libraries/Schedule.sol\";\nimport \"../libraries/Purchase.sol\";\n\n/// @title AdPool - stores all ads accorss every space.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract AdPool is IAdPool, BlockTimestamp, NameAccessor {\n\t/// @dev tokenId <- metadata * displayStartTimestamp * displayEndTimestamp\n\tmapping(uint256 => Ad.Period) public periods;\n\n\t/// @dev Returns spaceId that is tied with space metadata.\n\tmapping(string => bool) public spaced;\n\n\t/// @dev Maps the space metadata with tokenIds of ad periods.\n\tmapping(string => uint256[]) internal _periodKeys;\n\n\tmodifier onlyProxies() {\n\t\trequire(_mediaRegistry().ownerOf(msg.sender) != address(0x0), \"KD011\");\n\t\t_;\n\t}\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction addSpace(string memory metadata) external virtual onlyProxies {\n\t\trequire(!spaced[metadata], \"KD100\");\n\t\tspaced[metadata] = true;\n\t\t_event().emitNewSpace(metadata);\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction addPeriod(\n\t\taddress proxy,\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t) external virtual onlyProxies returns (uint256 tokenId) {\n\t\trequire(saleEndTimestamp > _blockTimestamp(), \"KD111\");\n\t\trequire(saleEndTimestamp <= displayStartTimestamp, \"KD112\");\n\t\trequire(displayStartTimestamp < displayEndTimestamp, \"KD113\");\n\n\t\t_addSpaceIfNot(spaceMetadata);\n\t\t_checkOverlapping(\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp\n\t\t);\n\t\ttokenId = Ad.id(spaceMetadata, displayStartTimestamp, displayEndTimestamp);\n\t\tAd.Period memory period = Ad.Period(\n\t\t\tproxy,\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\t_blockTimestamp(),\n\t\t\tsaleEndTimestamp,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tpricing,\n\t\t\tminPrice,\n\t\t\t0,\n\t\t\tfalse\n\t\t);\n\t\tperiod.startPrice = Sale.startPrice(period);\n\t\tperiods[tokenId] = period;\n\t\t_periodKeys[spaceMetadata].push(tokenId);\n\t\t_event().emitNewPeriod(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\t_blockTimestamp(),\n\t\t\tsaleEndTimestamp,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tpricing,\n\t\t\tminPrice\n\t\t);\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction deletePeriod(uint256 tokenId) external virtual onlyProxies {\n\t\trequire(periods[tokenId].mediaProxy != address(0), \"KD114\");\n\t\trequire(!_alreadyBid(tokenId), \"KD128\");\n\t\tstring memory spaceMetadata = periods[tokenId].spaceMetadata;\n\t\tuint256 index = 0;\n\t\tfor (uint256 i = 1; i < _periodKeys[spaceMetadata].length + 1; i++) {\n\t\t\tif (_periodKeys[spaceMetadata][i - 1] == tokenId) {\n\t\t\t\tindex = i;\n\t\t\t}\n\t\t}\n\t\trequire(index != 0, \"No deletable keys\");\n\t\tdelete _periodKeys[spaceMetadata][index - 1];\n\t\tdelete periods[tokenId];\n\t\t_event().emitDeletePeriod(tokenId);\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction soldByFixedPrice(uint256 tokenId, uint256 msgValue)\n\t\texternal\n\t\tonlyProxies\n\t{\n\t\tPurchase.checkBeforeBuy(periods[tokenId], msgValue);\n\t\tperiods[tokenId].sold = true;\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction soldByDutchAuction(uint256 tokenId, uint256 msgValue)\n\t\texternal\n\t\tonlyProxies\n\t{\n\t\tPurchase.checkBeforeBuyBasedOnTime(\n\t\t\tperiods[tokenId],\n\t\t\tcurrentPrice(tokenId),\n\t\t\t_blockTimestamp(),\n\t\t\tmsgValue\n\t\t);\n\t\tperiods[tokenId].sold = true;\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction bidByEnglishAuction(\n\t\tuint256 tokenId,\n\t\taddress msgSender,\n\t\tuint256 msgValue\n\t) external onlyProxies returns (Sale.Bidding memory) {\n\t\tPurchase.checkBeforeBid(\n\t\t\tperiods[tokenId],\n\t\t\tcurrentPrice(tokenId),\n\t\t\t_blockTimestamp(),\n\t\t\tmsgValue\n\t\t);\n\t\treturn _english().bid(tokenId, msgSender, msgValue);\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction soldByEnglishAuction(uint256 tokenId)\n\t\texternal\n\t\tonlyProxies\n\t\treturns (address bidder, uint256 price)\n\t{\n\t\t(bidder, price) = _english().receiveToken(tokenId);\n\t\tperiods[tokenId].sold = true;\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction bidWithProposal(\n\t\tuint256 tokenId,\n\t\tstring memory proposalMetadata,\n\t\taddress msgSender,\n\t\tuint256 msgValue\n\t) external onlyProxies {\n\t\tPurchase.checkBeforeBidWithProposal(\n\t\t\tperiods[tokenId],\n\t\t\t_blockTimestamp(),\n\t\t\tmsgValue\n\t\t);\n\t\t_openBid().bid(tokenId, proposalMetadata, msgSender, msgValue);\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction acceptOffer(\n\t\tuint256 tokenId,\n\t\tstring memory tokenMetadata,\n\t\tSale.Offer memory offer\n\t) external virtual onlyProxies {\n\t\t_checkOverlapping(\n\t\t\toffer.spaceMetadata,\n\t\t\toffer.displayStartTimestamp,\n\t\t\toffer.displayEndTimestamp\n\t\t);\n\t\tAd.Period memory period = Ad.Period(\n\t\t\toffer.sender,\n\t\t\toffer.spaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\t_blockTimestamp(),\n\t\t\t_blockTimestamp(),\n\t\t\toffer.displayStartTimestamp,\n\t\t\toffer.displayEndTimestamp,\n\t\t\tAd.Pricing.OFFER,\n\t\t\toffer.price,\n\t\t\toffer.price,\n\t\t\ttrue\n\t\t);\n\t\tperiods[tokenId] = period;\n\t\t_periodKeys[offer.spaceMetadata].push(tokenId);\n\t\t_event().emitAcceptOffer(\n\t\t\ttokenId,\n\t\t\toffer.spaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\toffer.displayStartTimestamp,\n\t\t\toffer.displayEndTimestamp,\n\t\t\toffer.price\n\t\t);\n\t}\n\n\tfunction allPeriods(uint256 tokenId)\n\t\texternal\n\t\tview\n\t\treturns (Ad.Period memory)\n\t{\n\t\treturn periods[tokenId];\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction currentPrice(uint256 tokenId) public view virtual returns (uint256) {\n\t\tAd.Period memory period = periods[tokenId];\n\t\tif (period.pricing == Ad.Pricing.RRP) {\n\t\t\treturn period.minPrice;\n\t\t}\n\t\tif (period.pricing == Ad.Pricing.DUTCH) {\n\t\t\treturn\n\t\t\t\tperiod.startPrice -\n\t\t\t\t((period.startPrice - period.minPrice) *\n\t\t\t\t\t(_blockTimestamp() - period.saleStartTimestamp)) /\n\t\t\t\t(period.saleEndTimestamp - period.saleStartTimestamp);\n\t\t}\n\t\tif (period.pricing == Ad.Pricing.ENGLISH) {\n\t\t\treturn _english().currentPrice(tokenId);\n\t\t}\n\t\tif (period.pricing == Ad.Pricing.OFFER) {\n\t\t\treturn _offerBid().currentPrice(tokenId);\n\t\t}\n\t\tif (period.pricing == Ad.Pricing.OPEN) {\n\t\t\treturn 0;\n\t\t}\n\t\trevert(\"not exist\");\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction display(string memory spaceMetadata)\n\t\texternal\n\t\tview\n\t\tvirtual\n\t\treturns (string memory, uint256)\n\t{\n\t\tuint256[] memory tokenIds = tokenIdsOf(spaceMetadata);\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tif (tokenIds[i] != 0) {\n\t\t\t\tAd.Period memory period = periods[tokenIds[i]];\n\t\t\t\tif (\n\t\t\t\t\tperiod.displayStartTimestamp <= _blockTimestamp() &&\n\t\t\t\t\tperiod.displayEndTimestamp >= _blockTimestamp()\n\t\t\t\t) {\n\t\t\t\t\tstring memory content = _review().acceptedContent(tokenIds[i]);\n\t\t\t\t\treturn (content, tokenIds[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (\"\", 0);\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction mediaProxyOf(uint256 tokenId) external view returns (address) {\n\t\treturn periods[tokenId].mediaProxy;\n\t}\n\n\t/// @inheritdoc IAdPool\n\tfunction tokenIdsOf(string memory spaceMetadata)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (uint256[] memory)\n\t{\n\t\treturn _periodKeys[spaceMetadata];\n\t}\n\n\tfunction _alreadyBid(uint256 tokenId) internal view virtual returns (bool) {\n\t\treturn\n\t\t\t_english().bidding(tokenId).bidder != address(0) ||\n\t\t\t_openBid().biddingList(tokenId).length != 0;\n\t}\n\n\tfunction _checkOverlapping(\n\t\tstring memory metadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp\n\t) internal view virtual {\n\t\tfor (uint256 i = 0; i < _periodKeys[metadata].length; i++) {\n\t\t\tuint256 existDisplayStart = periods[_periodKeys[metadata][i]]\n\t\t\t\t.displayStartTimestamp;\n\t\t\tuint256 existDisplayEnd = periods[_periodKeys[metadata][i]]\n\t\t\t\t.displayEndTimestamp;\n\n\t\t\tif (\n\t\t\t\tSchedule.isOverlapped(\n\t\t\t\t\tdisplayStartTimestamp,\n\t\t\t\t\tdisplayEndTimestamp,\n\t\t\t\t\texistDisplayStart,\n\t\t\t\t\texistDisplayEnd\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\trevert(\"KD110\");\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _addSpaceIfNot(string memory metadata) internal {\n\t\tif (!spaced[metadata]) {\n\t\t\tspaced[metadata] = true;\n\t\t\t_event().emitNewSpace(metadata);\n\t\t}\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _mediaRegistry() internal view returns (IMediaRegistry) {\n\t\treturn IMediaRegistry(mediaRegistryAddress());\n\t}\n\n\tfunction _event() internal view virtual returns (IEventEmitter) {\n\t\treturn IEventEmitter(eventEmitterAddress());\n\t}\n\n\tfunction _offerBid() internal view virtual returns (IOfferBid) {\n\t\treturn IOfferBid(offerBidAddress());\n\t}\n\n\tfunction _english() internal view virtual returns (IEnglishAuction) {\n\t\treturn IEnglishAuction(englishAuctionAddress());\n\t}\n\n\tfunction _review() internal view virtual returns (IProposalReview) {\n\t\treturn IProposalReview(proposalReviewAddress());\n\t}\n\n\tfunction _openBid() internal view virtual returns (IOpenBid) {\n\t\treturn IOpenBid(openBidAddress());\n\t}\n}\n"
    },
    "contracts/libraries/Schedule.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nlibrary Schedule {\n\tfunction isOverlapped(\n\t\tuint256 newFromTimestamp,\n\t\tuint256 newToTimestamp,\n\t\tuint256 currentFromTimestamp,\n\t\tuint256 currentToTimestamp\n\t) public pure returns (bool) {\n\t\treturn\n\t\t\t!(isPast(newToTimestamp, currentFromTimestamp) ||\n\t\t\t\tisFuture(newFromTimestamp, currentToTimestamp));\n\t}\n\n\tfunction isPast(uint256 newToTimestamp, uint256 currentFromTimestamp)\n\t\tpublic\n\t\tpure\n\t\treturns (bool)\n\t{\n\t\treturn newToTimestamp < currentFromTimestamp;\n\t}\n\n\tfunction isFuture(uint256 newFromTimestamp, uint256 currentToTimestamp)\n\t\tpublic\n\t\tpure\n\t\treturns (bool)\n\t{\n\t\treturn currentToTimestamp < newFromTimestamp;\n\t}\n}\n"
    },
    "contracts/test/MockTimeAdPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../peripheries/AdPool.sol\";\n\ncontract MockTimeAdPool is AdPool {\n\tuint256 public time;\n\n\tconstructor(address _nameRegistry) AdPool(_nameRegistry) {}\n\n\tfunction _blockTimestamp() internal view override returns (uint256) {\n\t\treturn time;\n\t}\n\n\tfunction setTime(uint256 _time) external {\n\t\ttime = _time;\n\t}\n}\n"
    },
    "contracts/peripheries/OpenBid.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Ad.sol\";\nimport \"../libraries/Purchase.sol\";\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"../interfaces/IAdPool.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\nimport \"../interfaces/IOpenBid.sol\";\nimport \"../interfaces/IMediaRegistry.sol\";\n\ncontract OpenBid is IOpenBid, BlockTimestamp, NameAccessor {\n\t/// @dev Maps a tokenId with appeal info\n\tmapping(uint256 => Sale.OpenBid[]) internal _bidding;\n\n\t/// @dev Maps a tokenId with the reason why the content is selected\n\tmapping(uint256 => string) public reasons;\n\n\tmodifier onlyProxies() {\n\t\trequire(_mediaRegistry().ownerOf(msg.sender) != address(0x0), \"KD011\");\n\t\t_;\n\t}\n\n\tmodifier onlyAdPool() {\n\t\trequire(msg.sender == adPoolAddress(), \"KD011\");\n\t\t_;\n\t}\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @inheritdoc IOpenBid\n\tfunction bid(\n\t\tuint256 tokenId,\n\t\tstring memory proposal,\n\t\taddress sender,\n\t\tuint256 value\n\t) external virtual onlyAdPool {\n\t\t_bidding[tokenId].push(Sale.OpenBid(tokenId, sender, value, proposal));\n\t\t_event().emitBidWithProposal(\n\t\t\ttokenId,\n\t\t\tvalue,\n\t\t\tsender,\n\t\t\tproposal,\n\t\t\t_blockTimestamp()\n\t\t);\n\t}\n\n\t/// @inheritdoc IOpenBid\n\tfunction selectProposal(\n\t\tuint256 tokenId,\n\t\tuint256 index,\n\t\tstring memory reason\n\t)\n\t\texternal\n\t\tvirtual\n\t\tonlyProxies\n\t\treturns (Sale.OpenBid memory selected, Sale.OpenBid[] memory nonSelected)\n\t{\n\t\trequire(\n\t\t\t_adPool().allPeriods(tokenId).saleEndTimestamp < _blockTimestamp(),\n\t\t\t\"KD129\"\n\t\t);\n\t\tselected = bidding(tokenId, index);\n\t\treasons[tokenId] = reason;\n\t\tdelete _bidding[tokenId][index];\n\t\tnonSelected = _bidding[tokenId];\n\t\tdelete _bidding[tokenId];\n\t\t_event().emitSelectProposal(tokenId, index, selected.sender, reason);\n\t}\n\n\tfunction biddingList(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\treturns (Sale.OpenBid[] memory)\n\t{\n\t\treturn _bidding[tokenId];\n\t}\n\n\tfunction bidding(uint256 tokenId, uint256 index)\n\t\tpublic\n\t\tview\n\t\treturns (Sale.OpenBid memory)\n\t{\n\t\trequire(\n\t\t\t_bidding[tokenId].length >= index &&\n\t\t\t\t_bidding[tokenId][index].sender != address(0),\n\t\t\t\"KD114\"\n\t\t);\n\t\treturn _bidding[tokenId][index];\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _adPool() internal view returns (IAdPool) {\n\t\treturn IAdPool(adPoolAddress());\n\t}\n\n\tfunction _event() internal view virtual returns (IEventEmitter) {\n\t\treturn IEventEmitter(eventEmitterAddress());\n\t}\n\n\tfunction _mediaRegistry() internal view returns (IMediaRegistry) {\n\t\treturn IMediaRegistry(mediaRegistryAddress());\n\t}\n}\n"
    },
    "contracts/test/MockTimeOpenBid.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../peripheries/OpenBid.sol\";\n\ncontract MockTimeOpenBid is OpenBid {\n\tuint256 public time;\n\n\tconstructor(address _nameRegistry) OpenBid(_nameRegistry) {}\n\n\tfunction _blockTimestamp() internal view override returns (uint256) {\n\t\treturn time;\n\t}\n\n\tfunction setTime(uint256 _time) external {\n\t\ttime = _time;\n\t}\n}\n"
    },
    "contracts/peripheries/OfferBid.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../libraries/Ad.sol\";\nimport \"../libraries/Purchase.sol\";\nimport \"../accessors/NameAccessor.sol\";\nimport \"../interfaces/IAdPool.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\nimport \"../interfaces/IOfferBid.sol\";\nimport \"../interfaces/IMediaRegistry.sol\";\n\ncontract OfferBid is IOfferBid, NameAccessor {\n\t/// @dev Maps a tokenId with offer info\n\tmapping(uint256 => Sale.Offer) internal _offered;\n\n\tmodifier onlyProxies() {\n\t\trequire(_mediaRegistry().ownerOf(msg.sender) != address(0x0), \"KD011\");\n\t\t_;\n\t}\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @inheritdoc IOfferBid\n\tfunction offer(\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\taddress sender,\n\t\tuint256 value\n\t) external virtual onlyProxies returns (uint256 tokenId) {\n\t\trequire(_adPool().spaced(spaceMetadata), \"KD101\");\n\t\trequire(displayStartTimestamp < displayEndTimestamp, \"KD113\");\n\t\ttokenId = Ad.id(spaceMetadata, displayStartTimestamp, displayEndTimestamp);\n\t\t_offered[tokenId] = Sale.Offer(\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tsender,\n\t\t\tvalue\n\t\t);\n\t\t_event().emitOfferPeriod(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tsender,\n\t\t\tvalue\n\t\t);\n\t}\n\n\t/// @inheritdoc IOfferBid\n\tfunction cancel(uint256 tokenId, address sender)\n\t\texternal\n\t\tvirtual\n\t\tonlyProxies\n\t\treturns (Sale.Offer memory prev)\n\t{\n\t\trequire(_offered[tokenId].sender == sender, \"KD116\");\n\t\tprev = _offered[tokenId];\n\t\tdelete _offered[tokenId];\n\t\t_event().emitCancelOffer(tokenId);\n\t}\n\n\t/// @inheritdoc IOfferBid\n\tfunction accept(uint256 tokenId)\n\t\texternal\n\t\tvirtual\n\t\tonlyProxies\n\t\treturns (Sale.Offer memory)\n\t{\n\t\tSale.Offer memory target = _offered[tokenId];\n\t\trequire(target.sender != address(0), \"KD115\");\n\t\tdelete _offered[tokenId];\n\t\treturn target;\n\t}\n\n\t/// @inheritdoc IOfferBid\n\tfunction currentPrice(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _offered[tokenId].price;\n\t}\n\n\tfunction offered(uint256 tokenId) external view returns (Sale.Offer memory) {\n\t\treturn _offered[tokenId];\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _adPool() internal view returns (IAdPool) {\n\t\treturn IAdPool(adPoolAddress());\n\t}\n\n\tfunction _event() internal view virtual returns (IEventEmitter) {\n\t\treturn IEventEmitter(eventEmitterAddress());\n\t}\n\n\tfunction _mediaRegistry() internal view returns (IMediaRegistry) {\n\t\treturn IMediaRegistry(mediaRegistryAddress());\n\t}\n}\n"
    },
    "contracts/peripheries/MediaRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"../interfaces/IMediaRegistry.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\n\n/// @title MediaRegistry - registers a list of media accounts.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract MediaRegistry is IMediaRegistry, BlockTimestamp, NameAccessor {\n\t/// @inheritdoc IMediaRegistry\n\tmapping(address => Account) public override allAccounts;\n\n\t/// @dev Throws if not called by MediaFacade proxies.\n\tmodifier onlyProxies() {\n\t\trequire(ownerOf(msg.sender) != address(0), \"KD011\");\n\t\t_;\n\t}\n\n\t/// @dev Throws if not called by MediaFactory.\n\tmodifier onlyFactory() {\n\t\trequire(msg.sender == mediaFactoryAddress(), \"KD010\");\n\t\t_;\n\t}\n\n\t/// Constructor\n\t/// @dev _nameRegistry address of the NameRegistry\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @dev Adds media account.\n\t/// @param proxy address of the proxy contract\n\t/// @param applicationMetadata string of constant metadata for the defailts of the account\n\t/// @param updatableMetadata string of constant metadata for the defailts of the account\n\t/// @param mediaEOA address of the media account\n\tfunction addMedia(\n\t\taddress proxy,\n\t\tstring memory applicationMetadata,\n\t\tstring memory updatableMetadata,\n\t\taddress mediaEOA\n\t) external onlyFactory {\n\t\tallAccounts[proxy] = Account(\n\t\t\tproxy,\n\t\t\tmediaEOA,\n\t\t\tapplicationMetadata,\n\t\t\tupdatableMetadata\n\t\t);\n\t}\n\n\t/// @dev Updates media account. It can be called by media proxies.\n\t/// @param metadata string of the account metadata\n\t/// @param mediaEOA address of the media account\n\tfunction updateMedia(address mediaEOA, string memory metadata)\n\t\texternal\n\t\tonlyProxies\n\t{\n\t\tallAccounts[msg.sender].mediaEOA = mediaEOA;\n\t\tallAccounts[msg.sender].updatableMetadata = metadata;\n\t\t_event().emitUpdateMedia(msg.sender, mediaEOA, metadata);\n\t}\n\n\t/// @dev Updates media account. It can only be called by the deployer as it is an application info.\n\t/// @param proxy string of the account metadata\n\t/// @param metadata address of the media account\n\tfunction updateApplicationMetadata(address proxy, string memory metadata)\n\t\texternal\n\t\tonlyOwner\n\t{\n\t\tallAccounts[proxy].applicationMetadata = metadata;\n\t}\n\n\t/// @dev Returns whether the account has created or not.\n\t/// @param proxy address of the proxy contract that represents an account.\n\tfunction created(address proxy) public view returns (bool) {\n\t\treturn allAccounts[proxy].proxy != address(0x0);\n\t}\n\n\t/// @dev Returns the owner of the account.\n\t/// @param proxy address of the proxy contract that represents an account.\n\tfunction ownerOf(address proxy) public view returns (address) {\n\t\treturn allAccounts[proxy].mediaEOA;\n\t}\n\n\tfunction _event() internal view virtual returns (IEventEmitter) {\n\t\treturn IEventEmitter(eventEmitterAddress());\n\t}\n}\n"
    },
    "contracts/peripheries/EventEmitter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"../interfaces/IMediaRegistry.sol\";\nimport \"../interfaces/IEventEmitter.sol\";\n\n/// @title EventEmitter - emits events on behalf of each proxy.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract EventEmitter is IEventEmitter, NameAccessor, BlockTimestamp {\n\t/// @dev Emitted when a new media is created.\n\tevent NewMedia(\n\t\taddress proxy,\n\t\taddress mediaEOA,\n\t\tstring applicationMetadata,\n\t\tstring updatableMetadata,\n\t\tuint256 saltNonce\n\t);\n\tevent UpdateMedia(address proxy, address mediaEOA, string accountMetadata);\n\tevent NewSpace(string metadata);\n\tevent NewPeriod(\n\t\tuint256 tokenId,\n\t\tstring spaceMetadata,\n\t\tstring tokenMetadata,\n\t\tuint256 saleStartTimestamp,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t);\n\tevent DeletePeriod(uint256 tokenId);\n\tevent Buy(uint256 tokenId, uint256 price, address buyer, uint256 timestamp);\n\tevent Bid(uint256 tokenId, uint256 price, address buyer, uint256 timestamp);\n\tevent BidWithProposal(\n\t\tuint256 tokenId,\n\t\tuint256 price,\n\t\taddress sender,\n\t\tstring metadata,\n\t\tuint256 timestamp\n\t);\n\tevent SelectProposal(\n\t\tuint256 tokenId,\n\t\tuint256 index,\n\t\taddress successfulBidder,\n\t\tstring reason\n\t);\n\tevent ReceiveToken(\n\t\tuint256 tokenId,\n\t\tuint256 price,\n\t\taddress buyer,\n\t\tuint256 timestamp\n\t);\n\tevent OfferPeriod(\n\t\tuint256 tokenId,\n\t\tstring spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\taddress sender,\n\t\tuint256 price\n\t);\n\tevent CancelOffer(uint256 tokenId);\n\tevent AcceptOffer(\n\t\tuint256 tokenId,\n\t\tstring spaceMetadata,\n\t\tstring tokenMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tuint256 price\n\t);\n\tevent Withdraw(uint256 amount);\n\tevent Propose(uint256 tokenId, string metadata);\n\tevent AcceptProposal(uint256 tokenId, string metadata);\n\tevent DenyProposal(\n\t\tuint256 tokenId,\n\t\tstring metadata,\n\t\tstring reason,\n\t\tbool offensive\n\t);\n\tevent TransferCustom(\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\tuint256 indexed tokenId\n\t);\n\tevent PaymentFailure(address receiver, uint256 price);\n\tevent Received(address, uint256);\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\tmodifier onlyProxies() {\n\t\trequire(_mediaRegistry().ownerOf(msg.sender) != address(0x0), \"KD011\");\n\t\t_;\n\t}\n\n\t/// @dev Throws if not called by MediaFactory.\n\tmodifier onlyFactory() {\n\t\trequire(msg.sender == mediaFactoryAddress(), \"KD010\");\n\t\t_;\n\t}\n\n\tmodifier onlyRegistry() {\n\t\trequire(msg.sender == mediaRegistryAddress(), \"KD011\");\n\t\t_;\n\t}\n\n\tfunction emitNewSpace(string memory metadata) external onlyAllowedContract {\n\t\temit NewSpace(metadata);\n\t}\n\n\tfunction emitNewPeriod(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 saleStartTimestamp,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t) external onlyAllowedContract {\n\t\temit NewPeriod(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\tsaleStartTimestamp,\n\t\t\tsaleEndTimestamp,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tpricing,\n\t\t\tminPrice\n\t\t);\n\t}\n\n\tfunction emitDeletePeriod(uint256 tokenId) external onlyAllowedContract {\n\t\temit DeletePeriod(tokenId);\n\t}\n\n\tfunction emitBuy(\n\t\tuint256 tokenId,\n\t\tuint256 msgValue,\n\t\taddress msgSender,\n\t\tuint256 blockTimestamp\n\t) external onlyProxies {\n\t\temit Buy(tokenId, msgValue, msgSender, blockTimestamp);\n\t}\n\n\tfunction emitBid(\n\t\tuint256 tokenId,\n\t\tuint256 msgValue,\n\t\taddress msgSender,\n\t\tuint256 blockTimestamp\n\t) external onlyAllowedContract {\n\t\temit Bid(tokenId, msgValue, msgSender, blockTimestamp);\n\t}\n\n\tfunction emitBidWithProposal(\n\t\tuint256 tokenId,\n\t\tuint256 msgValue,\n\t\taddress msgSender,\n\t\tstring memory metadata,\n\t\tuint256 blockTimestamp\n\t) external onlyAllowedContract {\n\t\temit BidWithProposal(\n\t\t\ttokenId,\n\t\t\tmsgValue,\n\t\t\tmsgSender,\n\t\t\tmetadata,\n\t\t\tblockTimestamp\n\t\t);\n\t}\n\n\tfunction emitSelectProposal(\n\t\tuint256 tokenId,\n\t\tuint256 index,\n\t\taddress successfulBidder,\n\t\tstring memory reason\n\t) external onlyAllowedContract {\n\t\temit SelectProposal(tokenId, index, successfulBidder, reason);\n\t}\n\n\tfunction emitReceiveToken(\n\t\tuint256 tokenId,\n\t\tuint256 price,\n\t\taddress buyer,\n\t\tuint256 blockTimestamp\n\t) external onlyAllowedContract {\n\t\temit ReceiveToken(tokenId, price, buyer, blockTimestamp);\n\t}\n\n\tfunction emitOfferPeriod(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\taddress sender,\n\t\tuint256 price\n\t) external onlyAllowedContract {\n\t\temit OfferPeriod(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tsender,\n\t\t\tprice\n\t\t);\n\t}\n\n\tfunction emitCancelOffer(uint256 tokenId) external onlyAllowedContract {\n\t\temit CancelOffer(tokenId);\n\t}\n\n\tfunction emitAcceptOffer(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tuint256 price\n\t) external onlyAllowedContract {\n\t\temit AcceptOffer(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tprice\n\t\t);\n\t}\n\n\tfunction emitWithdraw(uint256 amount) external onlyProxies {\n\t\temit Withdraw(amount);\n\t}\n\n\tfunction emitPropose(uint256 tokenId, string memory metadata)\n\t\texternal\n\t\tonlyAllowedContract\n\t{\n\t\temit Propose(tokenId, metadata);\n\t}\n\n\tfunction emitAcceptProposal(uint256 tokenId, string memory metadata)\n\t\texternal\n\t\tonlyAllowedContract\n\t{\n\t\temit AcceptProposal(tokenId, metadata);\n\t}\n\n\tfunction emitDenyProposal(\n\t\tuint256 tokenId,\n\t\tstring memory metadata,\n\t\tstring memory reason,\n\t\tbool offensive\n\t) external onlyAllowedContract {\n\t\temit DenyProposal(tokenId, metadata, reason, offensive);\n\t}\n\n\tfunction emitTransferCustom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external onlyProxies {\n\t\temit TransferCustom(from, to, tokenId);\n\t}\n\n\tfunction emitNewMedia(\n\t\taddress proxy,\n\t\taddress mediaEOA,\n\t\tstring memory applicationMetadata,\n\t\tstring memory updatableMetadata,\n\t\tuint256 saltNonce\n\t) external onlyFactory {\n\t\temit NewMedia(\n\t\t\tproxy,\n\t\t\tmediaEOA,\n\t\t\tapplicationMetadata,\n\t\t\tupdatableMetadata,\n\t\t\tsaltNonce\n\t\t);\n\t}\n\n\tfunction emitUpdateMedia(\n\t\taddress proxy,\n\t\taddress mediaEOA,\n\t\tstring memory accountMetadata\n\t) external onlyRegistry {\n\t\temit UpdateMedia(proxy, mediaEOA, accountMetadata);\n\t}\n\n\tfunction emitPaymentFailure(address receiver, uint256 price)\n\t\texternal\n\t\tonlyAllowedContract\n\t{\n\t\temit PaymentFailure(receiver, price);\n\t}\n\n\tfunction emitReceived(address receiver, uint256 price) external onlyProxies {\n\t\temit Received(receiver, price);\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _mediaRegistry() internal view returns (IMediaRegistry) {\n\t\treturn IMediaRegistry(mediaRegistryAddress());\n\t}\n}\n"
    },
    "contracts/peripheries/Vault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../common/EtherPaymentFallback.sol\";\n\n/// @title Vault - collects fees as the system usage.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract Vault is Ownable, EtherPaymentFallback {\n\tevent Withdraw(address sender, uint256 value);\n\tevent PaymentFailure(address receiver, uint256 price);\n\n\tfunction balance() public view returns (uint256) {\n\t\treturn address(this).balance;\n\t}\n\n\t/// @dev Withdraws the fund from the vault contract.\n\t/// @param amount uint256 of the amount the owner wants to withdraw\n\tfunction withdraw(uint256 amount) external onlyOwner {\n\t\trequire(amount <= balance(), \"KD140\");\n\t\t(bool success, ) = payable(msg.sender).call{ value: amount, gas: 10000 }(\n\t\t\t\"\"\n\t\t);\n\t\tif (success) {\n\t\t\temit Withdraw(msg.sender, amount);\n\t\t} else {\n\t\t\temit PaymentFailure(msg.sender, amount);\n\t\t}\n\t}\n}\n"
    },
    "contracts/common/EtherPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract EtherPaymentFallback {\n\tevent Received(address, uint256);\n\n\t/// @dev Fallback function accepts Ether transactions.\n\treceive() external payable virtual {\n\t\temit Received(msg.sender, msg.value);\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}