{
  "language": "Solidity",
  "sources": {
    "contracts/accessors/NameAccessor.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./NameRegistry.sol\";\n\n/// @title NameAccessor - manages the endpoints.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract NameAccessor {\n\tNameRegistry internal _nameRegistry;\n\n\t/// @dev Sets the address of NameRegistry.\n\t/// @param nameRegistry address of the NameRegistry\n\tfunction initialize(address nameRegistry) internal {\n\t\t_nameRegistry = NameRegistry(nameRegistry);\n\t}\n\n\t/// @dev Prevents calling a function from anyone except the accepted contract.\n\tmodifier onlyAllowedContract() {\n\t\trequire(_nameRegistry.allowedContracts(msg.sender), \"KD013\");\n\t\t_;\n\t}\n\n\tmodifier onlyFactory() {\n\t\trequire(msg.sender == mediaFactoryAddress(), \"KD010\");\n\t\t_;\n\t}\n\n\t/// @dev Throws if called by any account other than the owner.\n\tmodifier onlyOwner() {\n\t\trequire(owner() == msg.sender, \"KD012\");\n\t\t_;\n\t}\n\n\t/// @dev Gets the address of NameRegistry\n\tfunction nameRegistryAddress() public view returns (address) {\n\t\treturn address(_nameRegistry);\n\t}\n\n\t/// @dev Gets the address of AdPool.\n\tfunction adPoolAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"AdPool\")));\n\t}\n\n\t/// @dev Gets the address of MediaFactory.\n\tfunction mediaFactoryAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"MediaFactory\")));\n\t}\n\n\t/// @dev Gets the address of MediaRegistry.\n\tfunction mediaRegistryAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"MediaRegistry\")));\n\t}\n\n\t/// @dev Gets the address of Vault.\n\tfunction vaultAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"Vault\")));\n\t}\n\n\t/// @dev Gets the address of EventEmitter.\n\tfunction eventEmitterAddress() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"EventEmitter\")));\n\t}\n\n\t/// @dev Gets the owner address.\n\tfunction owner() public view returns (address) {\n\t\treturn _nameRegistry.owner();\n\t}\n}\n"
    },
    "contracts/accessors/NameRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title NameRegistry - saves a set of addresses.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract NameRegistry is Ownable {\n\tusing Address for address;\n\n\tmapping(address => bool) public allowedContracts;\n\tmapping(bytes32 => address) private _addressStorage;\n\n\tconstructor() Ownable() {}\n\n\t/// @dev Sets the address associated with the key name.\n\t///      If the address is the contract, not an EOA, it is\n\t///      saved as the allowed contract list.\n\t/// @param key bytes32 of the key\n\t/// @param value address of the value\n\tfunction set(bytes32 key, address value) public onlyOwner {\n\t\t_addressStorage[key] = value;\n\t\tif (value.isContract()) {\n\t\t\tallowedContracts[value] = true;\n\t\t}\n\t}\n\n\t/// @dev Gets the address associated with the key name.\n\t/// @param key bytes32 of the key\n\tfunction get(bytes32 key) public view returns (address) {\n\t\treturn _addressStorage[key];\n\t}\n}\n"
    },
    "contracts/accessors/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n\taddress internal _owner;\n\n\tevent OwnershipTransferred(\n\t\taddress indexed previousOwner,\n\t\taddress indexed newOwner\n\t);\n\n\t/**\n\t * @dev Initializes the contract setting the deployer as the initial owner.\n\t */\n\tconstructor() {\n\t\t_setOwner(_msgSender());\n\t}\n\n\t/**\n\t * @dev Returns the address of the current owner.\n\t */\n\tfunction owner() public view virtual returns (address) {\n\t\treturn _owner;\n\t}\n\n\t/**\n\t * @dev Throws if called by any account other than the owner.\n\t */\n\tmodifier onlyOwner() {\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Leaves the contract without owner. It will not be possible to call\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\n\t *\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\n\t * thereby removing any functionality that is only available to the owner.\n\t */\n\tfunction renounceOwnership() public virtual onlyOwner {\n\t\t_setOwner(address(0));\n\t}\n\n\t/**\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\n\t * Can only be called by the current owner.\n\t */\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\n\t\t_setOwner(newOwner);\n\t}\n\n\tfunction _setOwner(address newOwner) private {\n\t\taddress oldOwner = _owner;\n\t\t_owner = newOwner;\n\t\temit OwnershipTransferred(oldOwner, newOwner);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/token/Bundler.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/NameAccessor.sol\";\nimport \"../base/ERC721.sol\";\nimport \"../peripheries/AdPool.sol\";\nimport \"../peripheries/Vault.sol\";\nimport \"../libraries/Integers.sol\";\nimport \"../libraries/Substrings.sol\";\nimport \"../MediaFacade.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title Bundler - makes some NFTs be one to easily .\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract Bundler is ERC721, NameAccessor {\n\tevent BundleTokens(uint256 bundleId, string concatenated, string metadata);\n\n\tuint256 public nextBundleId;\n\tmapping(uint256 => string) tokenIds;\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t\tnextBundleId = 10000001;\n\t}\n\n\tfunction bundleTokens(string memory concatenated, string memory metadata)\n\t\texternal\n\t{\n\t\trequire(bytes(concatenated).length % 32 == 0, \"Inappropriate length\");\n\t\t_checkValidTokenIds(concatenated);\n\t\tfor (uint256 i = 0; i < bytes(concatenated).length / 32; i++) {\n\t\t\tstring memory sliced = Substrings.substring(\n\t\t\t\tconcatenated,\n\t\t\t\t32,\n\t\t\t\tint256(i * 32)\n\t\t\t);\n\t\t\tuint256 tokenId = Integers.parseInt(sliced);\n\t\t\taddress proxy = _adPool().mediaProxyOf(tokenId);\n\t\t\tMediaFacade manager = MediaFacade(proxy);\n\t\t\t// manager.transferToBundle(msg.sender, address(this), tokenId);\n\t\t}\n\t\ttokenIds[nextBundleId] = concatenated;\n\t\t_mint(address(this), nextBundleId);\n\t\t_tokenURIs[nextBundleId] = metadata;\n\t\temit BundleTokens(nextBundleId, concatenated, metadata);\n\t\tnextBundleId++;\n\t}\n\n\tfunction _checkValidTokenIds(string memory concatenated) internal view {\n\t\tfor (uint256 i = 0; i < bytes(concatenated).length / 32; i++) {\n\t\t\tstring memory sliced = Substrings.substring(\n\t\t\t\tconcatenated,\n\t\t\t\t32,\n\t\t\t\tint256(i * 32)\n\t\t\t);\n\t\t\tuint256 tokenId = Integers.parseInt(sliced);\n\t\t\taddress proxy = _adPool().mediaProxyOf(tokenId);\n\t\t\trequire(proxy != address(0), \"not exist\");\n\t\t}\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _adPool() internal view returns (AdPool) {\n\t\treturn AdPool(adPoolAddress());\n\t}\n}\n"
    },
    "contracts/base/ERC721.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../interfaces/IERC721Metadata.sol\";\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Context.sol\";\n\ncontract ERC721 is Context, IERC721Enumerable, IERC721Metadata {\n\tusing Address for address;\n\tusing Strings for uint256;\n\n\tstring internal dummy; // TODO: delete\n\n\t// Token name\n\tstring internal _name;\n\n\t// Token symbol\n\tstring internal _symbol;\n\n\t// Base URI\n\tstring internal _baseURI;\n\n\t// Token URIs\n\tmapping(uint256 => string) internal _tokenURIs;\n\n\t// Mapping from token ID to owner address\n\tmapping(uint256 => address) internal _owners;\n\n\t// Mapping owner address to token count\n\tmapping(address => uint256) internal _balances;\n\n\t// Mapping from token ID to approved address\n\tmapping(uint256 => address) internal _tokenApprovals;\n\n\t// Mapping from owner to operator approvals\n\tmapping(address => mapping(address => bool)) internal _operatorApprovals;\n\n\t// Mapping from owner to list of owned token IDs\n\tmapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n\t// Mapping from token ID to index of the owner tokens list\n\tmapping(uint256 => uint256) private _ownedTokensIndex;\n\n\t// Array with all token ids, used for enumeration\n\tuint256[] private _allTokens;\n\n\t// Mapping from token id to position in the allTokens array\n\tmapping(uint256 => uint256) private _allTokensIndex;\n\n\t/**\n\t * @dev See {IERC165-supportsInterface}.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId)\n\t\tpublic\n\t\tpure\n\t\tvirtual\n\t\toverride(IERC165)\n\t\treturns (bool)\n\t{\n\t\treturn\n\t\t\tinterfaceId == type(IERC721).interfaceId ||\n\t\t\tinterfaceId == type(IERC721Metadata).interfaceId;\n\t}\n\n\t/**\n\t * @dev See {IERC721-balanceOf}.\n\t */\n\tfunction balanceOf(address owner)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(owner != address(0), \"ERC721: balance query for the zero address\");\n\t\treturn _balances[owner];\n\t}\n\n\t/**\n\t * @dev See {IERC721-ownerOf}.\n\t */\n\tfunction ownerOf(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\taddress owner = _owners[tokenId];\n\t\trequire(owner != address(0), \"KD114\");\n\t\treturn owner;\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-name}.\n\t */\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-symbol}.\n\t */\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @dev See {IERC721Metadata-tokenURI}.\n\t */\n\tfunction tokenURI(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (string memory)\n\t{\n\t\trequire(\n\t\t\t_exists(tokenId),\n\t\t\t\"ERC721Metadata: URI query for nonexistent token\"\n\t\t);\n\n\t\treturn\n\t\t\tbytes(_baseURI).length > 0\n\t\t\t\t? string(abi.encodePacked(_baseURI, _tokenURIs[tokenId]))\n\t\t\t\t: _tokenURIs[tokenId];\n\t}\n\n\t/**\n\t * @dev See {IERC721-approve}.\n\t */\n\tfunction approve(address to, uint256 tokenId) public virtual override {\n\t\taddress owner = ownerOf(tokenId);\n\t\trequire(to != owner, \"ERC721: approval to current owner\");\n\n\t\trequire(\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n\t\t\t\"ERC721: approve caller is not owner nor approved for all\"\n\t\t);\n\n\t\t_approve(to, tokenId);\n\t}\n\n\t/**\n\t * @dev See {IERC721-getApproved}.\n\t */\n\tfunction getApproved(uint256 tokenId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (address)\n\t{\n\t\trequire(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n\t\treturn _tokenApprovals[tokenId];\n\t}\n\n\t/**\n\t * @dev See {IERC721-setApprovalForAll}.\n\t */\n\tfunction setApprovalForAll(address operator, bool approved)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t{\n\t\trequire(operator != _msgSender(), \"ERC721: approve to caller\");\n\n\t\t_operatorApprovals[_msgSender()][operator] = approved;\n\t\temit ApprovalForAll(_msgSender(), operator, approved);\n\t}\n\n\t/**\n\t * @dev See {IERC721-isApprovedForAll}.\n\t */\n\tfunction isApprovedForAll(address owner, address operator)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _operatorApprovals[owner][operator];\n\t}\n\n\t/**\n\t * @dev See {IERC721-transferFrom}.\n\t */\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public virtual override {\n\t\t//solhint-disable-next-line max-line-length\n\t\trequire(\n\t\t\t_isApprovedOrOwner(_msgSender(), tokenId),\n\t\t\t\"ERC721: transfer caller is not owner nor approved\"\n\t\t);\n\n\t\t_transfer(from, to, tokenId);\n\t}\n\n\t/**\n\t * @dev See {IERC721-safeTransferFrom}.\n\t */\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public virtual override {\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev See {IERC721-safeTransferFrom}.\n\t */\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) public virtual override {\n\t\trequire(\n\t\t\t_isApprovedOrOwner(_msgSender(), tokenId),\n\t\t\t\"ERC721: transfer caller is not owner nor approved\"\n\t\t);\n\t\t_safeTransfer(from, to, tokenId, _data);\n\t}\n\n\t/**\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n\t *\n\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n\t *\n\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n\t * implement alternative mechanisms to perform token transfer, such as signature-based.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _safeTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) internal virtual {\n\t\t_transfer(from, to, tokenId);\n\t\trequire(\n\t\t\t_checkOnERC721Received(from, to, tokenId, _data),\n\t\t\t\"ERC721: transfer to non ERC721Receiver implementer\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns whether `tokenId` exists.\n\t *\n\t * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n\t *\n\t * Tokens start existing when they are minted (`_mint`),\n\t * and stop existing when they are burned (`_burn`).\n\t */\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\n\t\treturn _owners[tokenId] != address(0);\n\t}\n\n\t/**\n\t * @dev Returns whether `spender` is allowed to manage `tokenId`.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\trequire(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n\t\taddress owner = ownerOf(tokenId);\n\t\treturn (spender == owner ||\n\t\t\tgetApproved(tokenId) == spender ||\n\t\t\tisApprovedForAll(owner, spender));\n\t}\n\n\t/**\n\t * @dev Safely mints `tokenId` and transfers it to `to`.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must not exist.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\n\t\t_safeMint(to, tokenId, \"\");\n\t}\n\n\t/**\n\t * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n\t * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n\t */\n\tfunction _safeMint(\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) internal virtual {\n\t\t_mint(to, tokenId);\n\t\trequire(\n\t\t\t_checkOnERC721Received(address(0), to, tokenId, _data),\n\t\t\t\"ERC721: transfer to non ERC721Receiver implementer\"\n\t\t);\n\t}\n\n\t/**\n\t * @dev Mints `tokenId` and transfers it to `to`.\n\t *\n\t * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must not exist.\n\t * - `to` cannot be the zero address.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _mint(address to, uint256 tokenId) internal virtual {\n\t\trequire(to != address(0), \"ERC721: mint to the zero address\");\n\t\trequire(!_exists(tokenId), \"ERC721: token already minted\");\n\n\t\t_beforeTokenTransfer(address(0), to, tokenId);\n\n\t\t_balances[to] += 1;\n\t\t_owners[tokenId] = to;\n\n\t\temit Transfer(address(0), to, tokenId);\n\t}\n\n\t/**\n\t * @dev Destroys `tokenId`.\n\t * The approval is cleared when the token is burned.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _burn(uint256 tokenId) internal virtual {\n\t\taddress owner = ownerOf(tokenId);\n\n\t\t_beforeTokenTransfer(owner, address(0), tokenId);\n\n\t\t// Clear approvals\n\t\t_approve(address(0), tokenId);\n\n\t\t_balances[owner] -= 1;\n\t\tdelete _owners[tokenId];\n\n\t\temit Transfer(owner, address(0), tokenId);\n\t}\n\n\t/**\n\t * @dev Transfers `tokenId` from `from` to `to`.\n\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n\t *\n\t * Requirements:\n\t *\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must be owned by `from`.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction _transfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal virtual {\n\t\trequire(\n\t\t\townerOf(tokenId) == from,\n\t\t\t\"ERC721: transfer of token that is not own\"\n\t\t);\n\t\trequire(to != address(0), \"ERC721: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(from, to, tokenId);\n\n\t\t// Clear approvals from the previous owner\n\t\t_approve(address(0), tokenId);\n\n\t\t_balances[from] -= 1;\n\t\t_balances[to] += 1;\n\t\t_owners[tokenId] = to;\n\n\t\temit Transfer(from, to, tokenId);\n\t}\n\n\t/**\n\t * @dev Approve `to` to operate on `tokenId`\n\t *\n\t * Emits a {Approval} event.\n\t */\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\n\t\t_tokenApprovals[tokenId] = to;\n\t\temit Approval(ownerOf(tokenId), to, tokenId);\n\t}\n\n\t/**\n\t * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n\t * The call is not executed if the target address is not a contract.\n\t *\n\t * @param from address representing the previous owner of the given token ID\n\t * @param to target address that will receive the tokens\n\t * @param tokenId uint256 ID of the token to be transferred\n\t * @param _data bytes optional data to send along with the call\n\t * @return bool whether the call correctly returned the expected magic value\n\t */\n\tfunction _checkOnERC721Received(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes memory _data\n\t) private returns (bool) {\n\t\tif (to.isContract()) {\n\t\t\ttry\n\t\t\t\tIERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)\n\t\t\treturns (bytes4 retval) {\n\t\t\t\treturn retval == IERC721Receiver(to).onERC721Received.selector;\n\t\t\t} catch (bytes memory reason) {\n\t\t\t\tif (reason.length == 0) {\n\t\t\t\t\trevert(\"ERC721: transfer to non ERC721Receiver implementer\");\n\t\t\t\t} else {\n\t\t\t\t\tassembly {\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Hook that is called before any token transfer. This includes minting\n\t * and burning.\n\t *\n\t * Calling conditions:\n\t *\n\t * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n\t * transferred to `to`.\n\t * - When `from` is zero, `tokenId` will be minted for `to`.\n\t * - When `to` is zero, ``from``'s `tokenId` will be burned.\n\t * - `from` and `to` are never both zero.\n\t *\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\t */\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) internal {\n\t\tif (from == address(0)) {\n\t\t\t_addTokenToAllTokensEnumeration(tokenId);\n\t\t} else if (from != to) {\n\t\t\t_removeTokenFromOwnerEnumeration(from, tokenId);\n\t\t}\n\t\tif (to == address(0)) {\n\t\t\t_removeTokenFromAllTokensEnumeration(tokenId);\n\t\t} else if (to != from) {\n\t\t\t_addTokenToOwnerEnumeration(to, tokenId);\n\t\t}\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n\t */\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(\n\t\t\tindex < balanceOf(owner),\n\t\t\t\"ERC721Enumerable: owner index out of bounds\"\n\t\t);\n\t\treturn _ownedTokens[owner][index];\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-totalSupply}.\n\t */\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _allTokens.length;\n\t}\n\n\t/**\n\t * @dev See {IERC721Enumerable-tokenByIndex}.\n\t */\n\tfunction tokenByIndex(uint256 index)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\trequire(\n\t\t\tindex < totalSupply(),\n\t\t\t\"ERC721Enumerable: global index out of bounds\"\n\t\t);\n\t\treturn _allTokens[index];\n\t}\n\n\t/**\n\t * @dev Private function to add a token to this extension's ownership-tracking data structures.\n\t * @param to address representing the new owner of the given token ID\n\t * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n\t */\n\tfunction _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n\t\tuint256 length = balanceOf(to);\n\t\t_ownedTokens[to][length] = tokenId;\n\t\t_ownedTokensIndex[tokenId] = length;\n\t}\n\n\t/**\n\t * @dev Private function to add a token to this extension's token tracking data structures.\n\t * @param tokenId uint256 ID of the token to be added to the tokens list\n\t */\n\tfunction _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n\t\t_allTokensIndex[tokenId] = _allTokens.length;\n\t\t_allTokens.push(tokenId);\n\t}\n\n\t/**\n\t * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n\t * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n\t * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n\t * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n\t * @param from address representing the previous owner of the given token ID\n\t * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n\t */\n\tfunction _removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\n\t\tprivate\n\t{\n\t\t// To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n\t\t// then delete the last slot (swap and pop).\n\n\t\tuint256 lastTokenIndex = balanceOf(from) - 1;\n\t\tuint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n\t\t// When the token to delete is the last token, the swap operation is unnecessary\n\t\tif (tokenIndex != lastTokenIndex) {\n\t\t\tuint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n\t\t\t_ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n\t\t\t_ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\t\t}\n\n\t\t// This also deletes the contents at the last position of the array\n\t\tdelete _ownedTokensIndex[tokenId];\n\t\tdelete _ownedTokens[from][lastTokenIndex];\n\t}\n\n\t/**\n\t * @dev Private function to remove a token from this extension's token tracking data structures.\n\t * This has O(1) time complexity, but alters the order of the _allTokens array.\n\t * @param tokenId uint256 ID of the token to be removed from the tokens list\n\t */\n\tfunction _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n\t\t// To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n\t\t// then delete the last slot (swap and pop).\n\n\t\tuint256 lastTokenIndex = _allTokens.length - 1;\n\t\tuint256 tokenIndex = _allTokensIndex[tokenId];\n\n\t\t// When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n\t\t// rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n\t\t// an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n\t\tuint256 lastTokenId = _allTokens[lastTokenIndex];\n\n\t\t_allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n\t\t_allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n\t\t// This also deletes the contents at the last position of the array\n\t\tdelete _allTokensIndex[tokenId];\n\t\t_allTokens.pop();\n\t}\n}\n"
    },
    "contracts/peripheries/AdPool.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"../libraries/Ad.sol\";\nimport \"./MediaRegistry.sol\";\n\n/// @title AdPool - stores all ads accorss every space.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract AdPool is BlockTimestamp, NameAccessor {\n\t/// @dev tokenId <- metadata * displayStartTimestamp * displayEndTimestamp\n\tmapping(uint256 => Ad.Period) public allPeriods;\n\n\tmodifier onlyProxies() {\n\t\trequire(_mediaRegistry().ownerOf(msg.sender) != address(0x0), \"KD011\");\n\t\t_;\n\t}\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\tfunction addPeriod(uint256 tokenId, Ad.Period memory period)\n\t\texternal\n\t\tonlyProxies\n\t{\n\t\tallPeriods[tokenId] = period;\n\t}\n\n\tfunction deletePeriod(uint256 tokenId) external onlyProxies {\n\t\tdelete allPeriods[tokenId];\n\t}\n\n\tfunction mediaProxyOf(uint256 tokenId) public view returns (address) {\n\t\treturn allPeriods[tokenId].mediaProxy;\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _mediaRegistry() internal view returns (MediaRegistry) {\n\t\treturn MediaRegistry(mediaRegistryAddress());\n\t}\n}\n"
    },
    "contracts/peripheries/Vault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/Ownable.sol\";\nimport \"../common/EtherPaymentFallback.sol\";\n\n/// @title Vault - collects fees as the system usage.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract Vault is Ownable, EtherPaymentFallback {\n\tevent Withdraw(address sender, uint256 value);\n\n\tfunction balance() public view returns (uint256) {\n\t\treturn address(this).balance;\n\t}\n\n\t/// @dev Withdraws the fund from the vault contract.\n\t/// @param amount uint256 of the amount the owner wants to withdraw\n\tfunction withdraw(uint256 amount) public onlyOwner {\n\t\trequire(amount <= balance(), \"KD140\");\n\t\tpayable(msg.sender).transfer(amount);\n\t\temit Withdraw(msg.sender, amount);\n\t}\n}\n"
    },
    "contracts/libraries/Integers.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title Integers - utilities for Integers.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nlibrary Integers {\n\tfunction parseInt(string memory _value) public pure returns (uint256 _ret) {\n\t\tbytes memory b = bytes(_value);\n\t\tuint256 i;\n\t\t_ret = 0;\n\t\tfor (i = 0; i < b.length; i++) {\n\t\t\tuint256 c = uint8(b[i]);\n\t\t\tif (c >= 48 && c <= 57) {\n\t\t\t\t_ret = _ret * 10 + (c - 48);\n\t\t\t}\n\t\t}\n\t}\n}\n"
    },
    "contracts/libraries/Substrings.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title Substrings - utilities for Substrings.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nlibrary Substrings {\n\t/**\n\t * Sub String\n\t *\n\t * Extracts the beginning part of a string based on the desired length\n\t *\n\t * @param _base When being used for a data type this is the extended object\n\t *              otherwise this is the string that will be used for\n\t *              extracting the sub string from\n\t * @param _length The length of the sub string to be extracted from the base\n\t * @return string The extracted sub string\n\t */\n\tfunction substring(string memory _base, int256 _length)\n\t\tpublic\n\t\tpure\n\t\treturns (string memory)\n\t{\n\t\treturn substring(_base, _length, 0);\n\t}\n\n\t/**\n\t * Sub String\n\t *\n\t * Extracts the part of a string based on the desired length and offset. The\n\t * offset and length must not exceed the lenth of the base string.\n\t *\n\t * @param _base When being used for a data type this is the extended object\n\t *              otherwise this is the string that will be used for\n\t *              extracting the sub string from\n\t * @param _length The length of the sub string to be extracted from the base\n\t * @param _offset The starting point to extract the sub string from\n\t * @return string The extracted sub string\n\t */\n\tfunction substring(\n\t\tstring memory _base,\n\t\tint256 _length,\n\t\tint256 _offset\n\t) public pure returns (string memory) {\n\t\tbytes memory _baseBytes = bytes(_base);\n\n\t\tassert(uint256(_offset + _length) <= _baseBytes.length);\n\n\t\tstring memory _tmp = new string(uint256(_length));\n\t\tbytes memory _tmpBytes = bytes(_tmp);\n\n\t\tuint256 j = 0;\n\t\tfor (uint256 i = uint256(_offset); i < uint256(_offset + _length); i++) {\n\t\t\t_tmpBytes[j++] = _baseBytes[i];\n\t\t}\n\n\t\treturn string(_tmpBytes);\n\t}\n}\n"
    },
    "contracts/MediaFacade.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./base/PrimarySales.sol\";\nimport \"./base/DistributionRight.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title MediaFacade - manages ad spaces and its periods to sell them to users.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract MediaFacade is DistributionRight, PrimarySales, ReentrancyGuard {\n\t/// @dev Can call it by only the media\n\tmodifier onlyMedia() {\n\t\trequire(_mediaRegistry().ownerOf(address(this)) == msg.sender, \"KD012\");\n\t\t_;\n\t}\n\n\t/// @dev Prevents the media from calling by yourself\n\tmodifier exceptYourself() {\n\t\trequire(_mediaRegistry().ownerOf(address(this)) != msg.sender, \"KD014\");\n\t\t_;\n\t}\n\n\t/// @dev Called by the successful bidder\n\tmodifier onlySuccessfulBidder(uint256 tokenId) {\n\t\trequire(bidding[tokenId].bidder == msg.sender, \"KD126\");\n\t\t_;\n\t}\n\n\t/// @dev Can call it only once\n\tmodifier initializer() {\n\t\trequire(address(_nameRegistry) == address(0x0), \"AR000\");\n\t\t_;\n\t}\n\n\t/// @dev Initialize the instance.\n\t/// @param title string of the title of the instance\n\t/// @param baseURI string of the base URI\n\t/// @param nameRegistry address of NameRegistry\n\tfunction initialize(\n\t\tstring memory title,\n\t\tstring memory baseURI,\n\t\taddress nameRegistry\n\t) external {\n\t\t_name = title;\n\t\t_symbol = string(abi.encodePacked(\"Kaleido_\", title));\n\t\t_baseURI = baseURI;\n\t\tinitialize(nameRegistry);\n\t}\n\n\t/// @dev Updates the media EOA and the metadata.\n\t/// @param newMediaEOA address of a new EOA\n\t/// @param newMetadata string of a new metadata\n\tfunction updateMedia(address newMediaEOA, string memory newMetadata)\n\t\texternal\n\t\tonlyMedia\n\t{\n\t\t// TODO: add updatable metadata\n\t\t_mediaRegistry().updateMedia(newMediaEOA, newMetadata);\n\t\t_eventEmitter().emitUpdateMedia(address(this), newMediaEOA, newMetadata);\n\t}\n\n\t/// @dev Creates a new space for the media account.\n\t/// @param spaceMetadata string of the space metadata\n\tfunction newSpace(string memory spaceMetadata) external onlyMedia {\n\t\t_newSpace(spaceMetadata);\n\t}\n\n\t/// @dev Create a new period for a space. This function requires some params\n\t///      to decide which kinds of pricing way and how much price to get started.\n\t/// @param spaceMetadata string of the space metadata\n\t/// @param tokenMetadata string of the token metadata\n\t/// @param saleEndTimestamp uint256 of the end timestamp for the sale\n\t/// @param displayStartTimestamp uint256 of the start timestamp for the display\n\t/// @param displayEndTimestamp uint256 of the end timestamp for the display\n\t/// @param pricing uint256 of the pricing way\n\t/// @param minPrice uint256 of the minimum price to sell it out\n\tfunction newPeriod(\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t) external onlyMedia {\n\t\trequire(saleEndTimestamp > _blockTimestamp(), \"KD111\");\n\t\trequire(saleEndTimestamp < displayStartTimestamp, \"KD112\");\n\t\trequire(displayStartTimestamp < displayEndTimestamp, \"KD113\");\n\n\t\t// TODO: check spacemetadata if the data is already stored\n\t\tif (!spaced[spaceMetadata]) {\n\t\t\t_newSpace(spaceMetadata);\n\t\t}\n\t\t_checkOverlapping(\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp\n\t\t);\n\t\tuint256 tokenId = Ad.id(\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp\n\t\t);\n\t\t_periodKeys[spaceMetadata].push(tokenId);\n\t\tAd.Period memory period = Ad.Period(\n\t\t\taddress(this),\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\t_blockTimestamp(),\n\t\t\tsaleEndTimestamp,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tpricing,\n\t\t\tminPrice,\n\t\t\t0,\n\t\t\tfalse\n\t\t);\n\t\tperiod.startPrice = _startPrice(period);\n\t\tallPeriods[tokenId] = period;\n\t\t_mintRight(tokenId, tokenMetadata);\n\t\t_adPool().addPeriod(tokenId, period);\n\t\t_eventEmitter().emitNewPeriod(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\t_blockTimestamp(),\n\t\t\tsaleEndTimestamp,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tpricing,\n\t\t\tminPrice\n\t\t);\n\t\t_eventEmitter().emitTransferCustom(address(0), address(this), tokenId);\n\t}\n\n\t/// @dev Deletes a period and its token.\n\t///      If there is any users locking the fund for the sale, the amount would be transfered\n\t///      to the user when deleting the period.\n\t/// @param tokenId uint256 of the token ID\n\tfunction deletePeriod(uint256 tokenId) external onlyMedia {\n\t\trequire(allPeriods[tokenId].mediaProxy != address(0), \"KD114\");\n\t\trequire(ownerOf(tokenId) == address(this), \"KD121\");\n\t\t_refundLockedAmount(tokenId);\n\t\tdelete allPeriods[tokenId];\n\t\t// TODO: delete _periodKeys[spaceMetadata]\n\t\t_burnRight(tokenId);\n\t\t_adPool().deletePeriod(tokenId);\n\t\t_eventEmitter().emitDeletePeriod(tokenId);\n\t\t_eventEmitter().emitTransferCustom(address(this), address(0), tokenId);\n\t}\n\n\t/// @dev Buys the token that is defined as the specific period on an ad space.\n\t///      The price of the token is fixed.\n\t/// @param tokenId uint256 of the token ID\n\tfunction buy(uint256 tokenId) external payable exceptYourself {\n\t\t_checkBeforeBuy(tokenId);\n\t\tallPeriods[tokenId].sold = true;\n\t\t_dropRight(tokenId);\n\t\t_collectFees();\n\t\t_eventEmitter().emitBuy(tokenId, msg.value, msg.sender);\n\t\t_eventEmitter().emitTransferCustom(address(this), msg.sender, tokenId);\n\t}\n\n\t/// @dev Buys the token that is defined as the specific period on an ad space.\n\t///      The price is decreasing as time goes by.\n\t/// @param tokenId uint256 of the token ID\n\tfunction buyBasedOnTime(uint256 tokenId) external payable exceptYourself {\n\t\t_checkBeforeBuyBasedOnTime(tokenId);\n\t\tallPeriods[tokenId].sold = true;\n\t\t_dropRight(tokenId);\n\t\t_collectFees();\n\t\t_eventEmitter().emitBuy(tokenId, msg.value, msg.sender);\n\t\t_eventEmitter().emitTransferCustom(address(this), msg.sender, tokenId);\n\t}\n\n\t/// @dev Bids to participate in an auction.\n\t/// @param tokenId uint256 of the token ID\n\tfunction bid(uint256 tokenId) external payable exceptYourself nonReentrant {\n\t\t_checkBeforeBid(tokenId);\n\t\t_refundLockedAmount(tokenId);\n\t\tbidding[tokenId] = Bidding(tokenId, msg.sender, msg.value);\n\t\t_eventEmitter().emitBid(tokenId, msg.value, msg.sender);\n\t}\n\n\t/// @dev Receives the token you bidded if you are the successful bidder.\n\t/// @param tokenId uint256 of the token ID\n\tfunction receiveToken(uint256 tokenId)\n\t\texternal\n\t\tpayable\n\t\tonlySuccessfulBidder(tokenId)\n\t{\n\t\t_checkBeforeReceiveToken(tokenId);\n\t\tallPeriods[tokenId].sold = true;\n\t\t_dropRight(tokenId);\n\t\t_collectFees(); // TODO: modify\n\t\t_eventEmitter().emitReceiveToken(\n\t\t\ttokenId,\n\t\t\tbidding[tokenId].price,\n\t\t\tmsg.sender\n\t\t);\n\t\t_eventEmitter().emitTransferCustom(address(this), msg.sender, tokenId);\n\t}\n\n\t/// @dev Offers to buy a period that the sender requests.\n\t/// @param spaceMetadata string of the space metadata\n\t/// @param displayStartTimestamp uint256 of the start timestamp for the display\n\t/// @param displayEndTimestamp uint256 of the end timestamp for the display\n\tfunction offerPeriod(\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp\n\t) external payable exceptYourself {\n\t\trequire(spaced[spaceMetadata], \"KD101\");\n\t\trequire(displayStartTimestamp < displayEndTimestamp, \"KD113\");\n\t\tuint256 tokenId = Ad.id(\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp\n\t\t);\n\t\toffered[tokenId] = Offer(\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tmsg.sender,\n\t\t\tmsg.value\n\t\t);\n\t\t_eventEmitter().emitOfferPeriod(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tmsg.sender,\n\t\t\tmsg.value\n\t\t);\n\t}\n\n\t// TODO: cancel function\n\n\t/// @dev Accepts an offer by the Media.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param tokenMetadata string of the NFT token metadata\n\tfunction acceptOffer(uint256 tokenId, string memory tokenMetadata)\n\t\texternal\n\t\tonlyMedia\n\t{\n\t\tOffer memory offer = offered[tokenId];\n\t\trequire(offer.sender != address(0), \"KD115\");\n\t\t_checkOverlapping(\n\t\t\toffer.spaceMetadata,\n\t\t\toffer.displayStartTimestamp,\n\t\t\toffer.displayEndTimestamp\n\t\t);\n\t\tAd.Period memory period = Ad.Period(\n\t\t\taddress(this),\n\t\t\toffer.spaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\t_blockTimestamp(),\n\t\t\t_blockTimestamp(),\n\t\t\toffer.displayStartTimestamp,\n\t\t\toffer.displayEndTimestamp,\n\t\t\tAd.Pricing.OFFER,\n\t\t\toffer.price,\n\t\t\toffer.price,\n\t\t\ttrue\n\t\t);\n\t\tallPeriods[tokenId] = period;\n\t\t// TODO: adPool() * allPeriods * periodKeys\n\t\t_mintRight(tokenId, tokenMetadata); // TODO: transfer\n\t\t_collectFees(); // TODO: modify\n\t\t_eventEmitter().emitAcceptOffer(\n\t\t\ttokenId,\n\t\t\toffer.spaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\toffer.displayStartTimestamp,\n\t\t\toffer.displayEndTimestamp,\n\t\t\toffer.price\n\t\t);\n\t\t_eventEmitter().emitTransferCustom(address(0), address(this), tokenId);\n\t}\n\n\t/// @dev Withdraws the fund deposited to the proxy contract.\n\tfunction withdraw() external onlyMedia {\n\t\t// TODO: withdrawal amount\n\t\tuint256 remained = address(this).balance;\n\t\tpayable(msg.sender).transfer(remained);\n\t\t_eventEmitter().emitWithdraw(remained);\n\t}\n\n\t/// @dev Proposes the metadata to the token you bought.\n\t///      Users can propose many times as long as it is accepted.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param metadata string of the proposal metadata\n\tfunction propose(uint256 tokenId, string memory metadata) external {\n\t\trequire(ownerOf(tokenId) == msg.sender, \"KD012\");\n\t\t_proposeToRight(tokenId, metadata);\n\t\t_eventEmitter().emitPropose(tokenId, metadata);\n\t}\n\n\t/// @dev Accepts the proposal.\n\t/// @param tokenId uint256 of the token ID\n\tfunction accept(uint256 tokenId) external onlyMedia {\n\t\tstring memory metadata = proposed[tokenId];\n\t\trequire(bytes(metadata).length != 0, \"KD130\");\n\t\taddress currentOwner = ownerOf(tokenId);\n\t\t// TODO: check if the current owner is the same as the proposer\n\t\t// TODO: delete _burnRight(tokenId);\n\t\t_acceptProposal(tokenId, metadata);\n\t\t_eventEmitter().emitAcceptProposal(tokenId, metadata);\n\t\t_eventEmitter().emitTransferCustom(currentOwner, address(0), tokenId);\n\t}\n\n\t/// @dev Denies the submitted proposal, mentioning what is the problem.\n\t/// @param tokenId uint256 of the token ID\n\t/// @param reason string of the reason why it is rejected\n\t/// TODO: flag\n\tfunction deny(uint256 tokenId, string memory reason) external onlyMedia {\n\t\tstring memory metadata = proposed[tokenId];\n\t\trequire(bytes(metadata).length != 0, \"KD130\");\n\t\tdeniedReason[tokenId] = reason;\n\t\t// TODO: denies N\n\t\t_eventEmitter().emitDenyProposal(tokenId, metadata, reason);\n\t}\n\n\t/// @dev Overrides transferFrom to emit an event from the common emitter.\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public override {\n\t\tsuper.transferFrom(from, to, tokenId);\n\t\t_eventEmitter().emitTransferCustom(from, to, tokenId);\n\t}\n\n\t/// @dev Overrides transferFrom to emit an event from the common emitter.\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) public override {\n\t\tsuper.safeTransferFrom(from, to, tokenId);\n\t\t_eventEmitter().emitTransferCustom(from, to, tokenId);\n\t}\n\n\t/// @dev Returns ID based on the space metadata, display start timestamp, and\n\t///      display end timestamp. These three makes it the unique.\n\t/// @param spaceMetadata uint256 of the space metadata\n\t/// @param displayStartTimestamp uint256 of the start timestamp for the display\n\t/// @param displayEndTimestamp uint256 of the end timestamp for the display\n\tfunction adId(\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp\n\t) public pure returns (uint256) {\n\t\treturn Ad.id(spaceMetadata, displayStartTimestamp, displayEndTimestamp);\n\t}\n\n\t/// @dev Returns the balacne deposited on the proxy contract.\n\tfunction balance() public view returns (uint256) {\n\t\treturn address(this).balance;\n\t}\n\n\t/// @dev Displays the ad content that is approved by the media owner.\n\t/// @param spaceMetadata string of the space metadata\n\tfunction display(string memory spaceMetadata)\n\t\texternal\n\t\tview\n\t\treturns (string memory)\n\t{\n\t\tuint256[] memory tokenIds = tokenIdsOf(spaceMetadata);\n\t\tfor (uint256 i = 0; i < tokenIds.length; i++) {\n\t\t\tAd.Period memory period = allPeriods[tokenIds[i]];\n\t\t\tif (\n\t\t\t\tperiod.displayStartTimestamp <= _blockTimestamp() &&\n\t\t\t\tperiod.displayEndTimestamp >= _blockTimestamp()\n\t\t\t) {\n\t\t\t\treturn accepted[tokenIds[i]];\n\t\t\t}\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tfunction _checkBeforeReceiveToken(uint256 tokenId) internal view {\n\t\trequire(allPeriods[tokenId].pricing == Ad.Pricing.BIDDING, \"KD124\");\n\t\trequire(!allPeriods[tokenId].sold, \"KD121\");\n\t\trequire(allPeriods[tokenId].saleEndTimestamp < _blockTimestamp(), \"KD125\");\n\t}\n\n\tfunction _collectFees() internal {\n\t\tpayable(vaultAddress()).transfer(msg.value / 10);\n\t}\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\t/**\n\t * @dev Returns the token collection name.\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the token collection symbol.\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n\t */\n\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n\t/**\n\t * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n\t * by `operator` from `from`, this function is called.\n\t *\n\t * It must return its Solidity selector to confirm the token transfer.\n\t * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n\t *\n\t * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n\t */\n\tfunction onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes calldata data\n\t) external returns (bytes4);\n}\n"
    },
    "contracts/interfaces/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n\t/**\n\t * @dev Returns the total amount of tokens stored by the contract.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n\t * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n\t */\n\tfunction tokenOfOwnerByIndex(address owner, uint256 index)\n\t\texternal\n\t\tview\n\t\treturns (uint256 tokenId);\n\n\t/**\n\t * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n\t * Use along with {totalSupply} to enumerate all tokens.\n\t */\n\tfunction tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n\t/**\n\t * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n\t */\n\tevent Transfer(\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\tuint256 indexed tokenId\n\t);\n\n\t/**\n\t * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n\t */\n\tevent Approval(\n\t\taddress indexed owner,\n\t\taddress indexed approved,\n\t\tuint256 indexed tokenId\n\t);\n\n\t/**\n\t * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n\t */\n\tevent ApprovalForAll(\n\t\taddress indexed owner,\n\t\taddress indexed operator,\n\t\tbool approved\n\t);\n\n\t/**\n\t * @dev Returns the number of tokens in ``owner``'s account.\n\t */\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\n\n\t/**\n\t * @dev Returns the owner of the `tokenId` token.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\n\n\t/**\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external;\n\n\t/**\n\t * @dev Transfers `tokenId` token from `from` to `to`.\n\t *\n\t * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must be owned by `from`.\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external;\n\n\t/**\n\t * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n\t * The approval is cleared when the token is transferred.\n\t *\n\t * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n\t *\n\t * Requirements:\n\t *\n\t * - The caller must own the token or be an approved operator.\n\t * - `tokenId` must exist.\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address to, uint256 tokenId) external;\n\n\t/**\n\t * @dev Returns the account approved for `tokenId` token.\n\t *\n\t * Requirements:\n\t *\n\t * - `tokenId` must exist.\n\t */\n\tfunction getApproved(uint256 tokenId)\n\t\texternal\n\t\tview\n\t\treturns (address operator);\n\n\t/**\n\t * @dev Approve or remove `operator` as an operator for the caller.\n\t * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n\t *\n\t * Requirements:\n\t *\n\t * - The `operator` cannot be the caller.\n\t *\n\t * Emits an {ApprovalForAll} event.\n\t */\n\tfunction setApprovalForAll(address operator, bool _approved) external;\n\n\t/**\n\t * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n\t *\n\t * See {setApprovalForAll}\n\t */\n\tfunction isApprovedForAll(address owner, address operator)\n\t\texternal\n\t\tview\n\t\treturns (bool);\n\n\t/**\n\t * @dev Safely transfers `tokenId` token from `from` to `to`.\n\t *\n\t * Requirements:\n\t *\n\t * - `from` cannot be the zero address.\n\t * - `to` cannot be the zero address.\n\t * - `tokenId` token must exist and be owned by `from`.\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction safeTransferFrom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId,\n\t\tbytes calldata data\n\t) external;\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n\t/**\n\t * @dev Returns true if this contract implements the interface defined by\n\t * `interfaceId`. See the corresponding\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n\t * to learn more about how these ids are created.\n\t *\n\t * This function call must use less than 30 000 gas.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/common/BlockTimestamp.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title BlockTimestamp - gets a block timestamp.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nabstract contract BlockTimestamp {\n\t/// @dev Method that exists purely to be overridden for tests\n\tfunction _blockTimestamp() internal view virtual returns (uint256) {\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "contracts/libraries/Ad.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nlibrary Ad {\n\tuint256 private constant _ID_LENGTH = 100000000000000000000000000000000;\n\t// RBP : Recommended Retail Price\n\t// DPBT: Dynamic Pricing Based on Time\n\t// BIDDING : Auction, Bidding Price\n\t// OFFER: Offered by others\n\tenum Pricing {\n\t\tRRP,\n\t\tDPBT,\n\t\tBIDDING,\n\t\tOFFER\n\t}\n\tstruct Period {\n\t\taddress mediaProxy;\n\t\tstring spaceMetadata;\n\t\tstring tokenMetadata;\n\t\tuint256 saleStartTimestamp;\n\t\tuint256 saleEndTimestamp;\n\t\tuint256 displayStartTimestamp;\n\t\tuint256 displayEndTimestamp;\n\t\tPricing pricing;\n\t\tuint256 minPrice;\n\t\tuint256 startPrice;\n\t\tbool sold;\n\t}\n\n\tfunction id(\n\t\tstring memory metadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp\n\t) public pure returns (uint256) {\n\t\treturn\n\t\t\tuint256(\n\t\t\t\tkeccak256(\n\t\t\t\t\tabi.encodePacked(metadata, displayStartTimestamp, displayEndTimestamp)\n\t\t\t\t)\n\t\t\t) % _ID_LENGTH;\n\t}\n}\n"
    },
    "contracts/peripheries/MediaRegistry.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title MediaRegistry - registers a list of media accounts.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract MediaRegistry is BlockTimestamp, NameAccessor {\n\tstruct Account {\n\t\taddress proxy;\n\t\taddress mediaEOA;\n\t\tstring metadata;\n\t}\n\tmapping(address => Account) public allAccounts;\n\n\tmodifier onlyProxies() {\n\t\trequire(ownerOf(msg.sender) != address(0), \"KD011\");\n\t\t_;\n\t}\n\n\t/// Constructor\n\t/// @dev _nameRegistry address of the NameRegistry\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @dev Adds media account.\n\t/// @param proxy address of the proxy contract\n\t/// @param metadata string of the account metadata\n\t/// @param mediaEOA address of the media account\n\tfunction addMedia(\n\t\taddress proxy,\n\t\tstring memory metadata,\n\t\taddress mediaEOA\n\t) external onlyFactory {\n\t\tallAccounts[proxy] = Account(proxy, mediaEOA, metadata);\n\t}\n\n\t/// @dev Updates media account.\n\t/// @param metadata string of the account metadata\n\t/// @param mediaEOA address of the media account\n\tfunction updateMedia(address mediaEOA, string memory metadata)\n\t\texternal\n\t\tonlyProxies\n\t{\n\t\tallAccounts[msg.sender] = Account(msg.sender, mediaEOA, metadata);\n\t}\n\n\t/// @dev Returns whether the account has created or not.\n\t/// @param proxy address of the proxy contract that represents an account.\n\tfunction created(address proxy) public view returns (bool) {\n\t\treturn allAccounts[proxy].proxy != address(0x0);\n\t}\n\n\t/// @dev Returns the owner of the account.\n\t/// @param proxy address of the proxy contract that represents an account.\n\tfunction ownerOf(address proxy) public view returns (address) {\n\t\treturn allAccounts[proxy].mediaEOA;\n\t}\n}\n"
    },
    "contracts/common/EtherPaymentFallback.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title EtherPaymentFallback - A contract that has a fallback to accept ether payments.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract EtherPaymentFallback {\n\tevent Received(address, uint256);\n\n\t/// @dev Fallback function accepts Ether transactions.\n\treceive() external payable {\n\t\temit Received(msg.sender, msg.value);\n\t}\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/base/PrimarySales.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./PricingStrategy.sol\";\n\n/// @title PrimarySales - manages how to sell them out.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nabstract contract PrimarySales is PricingStrategy {\n\tfunction _checkBeforeBuy(uint256 tokenId) internal {\n\t\trequire(allPeriods[tokenId].pricing == Ad.Pricing.RRP, \"KD120\");\n\t\trequire(!allPeriods[tokenId].sold, \"KD121\");\n\t\trequire(allPeriods[tokenId].minPrice == msg.value, \"KD122\");\n\t}\n\n\tfunction _checkBeforeBuyBasedOnTime(uint256 tokenId) internal {\n\t\trequire(allPeriods[tokenId].pricing == Ad.Pricing.DPBT, \"KD123\");\n\t\trequire(!allPeriods[tokenId].sold, \"KD121\");\n\t\trequire(currentPrice(tokenId) <= msg.value, \"KD122\");\n\t}\n\n\tfunction _checkBeforeBid(uint256 tokenId) internal {\n\t\trequire(allPeriods[tokenId].pricing == Ad.Pricing.BIDDING, \"KD124\");\n\t\trequire(!allPeriods[tokenId].sold, \"KD121\");\n\t\trequire(currentPrice(tokenId) < msg.value, \"KD122\");\n\t}\n\n\tfunction _refundLockedAmount(uint256 tokenId) internal returns (bool sent) {\n\t\tif (\n\t\t\tallPeriods[tokenId].pricing == Ad.Pricing.BIDDING &&\n\t\t\tbidding[tokenId].bidder != address(0)\n\t\t) {\n\t\t\tsent = payable(bidding[tokenId].bidder).send(bidding[tokenId].price);\n\t\t}\n\t}\n}\n"
    },
    "contracts/base/DistributionRight.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./ERC721.sol\";\nimport \"../accessors/NameAccessor.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title DistributionRight - represents NFTs based on ad spaces and periods.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract DistributionRight is ERC721 {\n\tmapping(uint256 => string) public proposed;\n\tmapping(uint256 => string) public deniedReason;\n\tmapping(uint256 => string) public accepted;\n\n\tfunction _mintRight(uint256 tokenId, string memory metadata) internal {\n\t\t_mint(address(this), tokenId);\n\t\t_tokenURIs[tokenId] = metadata;\n\t}\n\n\tfunction _burnRight(uint256 tokenId) internal {\n\t\t_burn(tokenId);\n\t\t_tokenURIs[tokenId] = \"\";\n\t}\n\n\tfunction _dropRight(uint256 tokenId) internal {\n\t\t_transfer(address(this), msg.sender, tokenId);\n\t}\n\n\tfunction _proposeToRight(uint256 tokenId, string memory metadata) internal {\n\t\tproposed[tokenId] = metadata;\n\t}\n\n\tfunction _clearProposal(uint256 tokenId) internal {\n\t\tproposed[tokenId] = \"\";\n\t}\n\n\tfunction _acceptProposal(uint256 tokenId, string memory metadata) internal {\n\t\taccepted[tokenId] = metadata;\n\t\t_clearProposal(tokenId);\n\t}\n\n\t// function transferToBundle(\n\t// \taddress from,\n\t// \taddress to,\n\t// \tuint256 tokenId\n\t// ) external {\n\t// \t// TODO: only from bundler\n\t// \t_transfer(from, to, tokenId);\n\t// }\n}\n"
    },
    "contracts/base/PricingStrategy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./PeriodManager.sol\";\nimport \"../common/BlockTimestamp.sol\";\n\n/// @title PricingStrategy - manages how to sell them out.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nabstract contract PricingStrategy is PeriodManager, BlockTimestamp {\n\tstruct Bidding {\n\t\tuint256 tokenId;\n\t\taddress bidder;\n\t\tuint256 price;\n\t}\n\tstruct Offer {\n\t\tstring spaceMetadata;\n\t\tuint256 displayStartTimestamp;\n\t\tuint256 displayEndTimestamp;\n\t\taddress sender;\n\t\tuint256 price;\n\t}\n\t/// @dev Maps tokenId with bidding info\n\tmapping(uint256 => Bidding) public bidding;\n\n\t/// @dev Maps tokenId with offer info\n\tmapping(uint256 => Offer) public offered;\n\n\t/// @dev Returns the current price.\n\t/// @param tokenId uint256 of the token ID\n\tfunction currentPrice(uint256 tokenId) public view returns (uint256) {\n\t\tAd.Period memory period = allPeriods[tokenId];\n\t\tif (period.pricing == Ad.Pricing.RRP) {\n\t\t\treturn period.minPrice;\n\t\t}\n\t\tif (period.pricing == Ad.Pricing.DPBT) {\n\t\t\treturn\n\t\t\t\tperiod.startPrice -\n\t\t\t\t((period.startPrice - period.minPrice) *\n\t\t\t\t\t(_blockTimestamp() - period.saleStartTimestamp)) /\n\t\t\t\t(period.saleEndTimestamp - period.saleStartTimestamp);\n\t\t}\n\t\tif (period.pricing == Ad.Pricing.BIDDING) {\n\t\t\treturn bidding[tokenId].price;\n\t\t}\n\t\tif (period.pricing == Ad.Pricing.OFFER) {\n\t\t\treturn offered[tokenId].price;\n\t\t}\n\t\trevert(\"not exist\");\n\t}\n\n\tfunction _startPrice(Ad.Period memory period)\n\t\tinternal\n\t\tpure\n\t\treturns (uint256)\n\t{\n\t\tif (period.pricing == Ad.Pricing.RRP) {\n\t\t\treturn period.minPrice;\n\t\t} else if (period.pricing == Ad.Pricing.DPBT) {\n\t\t\treturn period.minPrice * 10;\n\t\t} else if (period.pricing == Ad.Pricing.BIDDING) {\n\t\t\treturn period.minPrice;\n\t\t} else if (period.pricing == Ad.Pricing.OFFER) {\n\t\t\treturn period.minPrice;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n}\n"
    },
    "contracts/base/PeriodManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./SpaceManager.sol\";\nimport \"../libraries/Ad.sol\";\n\n/// @title PeriodManager - manages ad periods.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nabstract contract PeriodManager is SpaceManager {\n\t/// @dev tokenId <- metadata * displayStartTimestamp * displayEndTimestamp\n\tmapping(uint256 => Ad.Period) public allPeriods;\n\n\t/// @dev Maps the space metadata with tokenIds of ad periods.\n\tmapping(string => uint256[]) internal _periodKeys;\n\n\tfunction _checkOverlapping(\n\t\tstring memory metadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp\n\t) internal view {\n\t\tfor (uint256 i = 0; i < _periodKeys[metadata].length; i++) {\n\t\t\tAd.Period memory existing = allPeriods[_periodKeys[metadata][i]];\n\t\t\tif (\n\t\t\t\t_isOverlapped(\n\t\t\t\t\tdisplayStartTimestamp,\n\t\t\t\t\tdisplayEndTimestamp,\n\t\t\t\t\texisting.displayStartTimestamp,\n\t\t\t\t\texisting.displayEndTimestamp\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\trevert(\"KD110\");\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction _isOverlapped(\n\t\tuint256 newFromTimestamp,\n\t\tuint256 newToTimestamp,\n\t\tuint256 currentFromTimestamp,\n\t\tuint256 currentToTimestamp\n\t) internal pure returns (bool) {\n\t\treturn\n\t\t\t!(_isPast(newToTimestamp, currentFromTimestamp) ||\n\t\t\t\t_isFuture(newFromTimestamp, currentToTimestamp));\n\t}\n\n\tfunction _isPast(uint256 newToTimestamp, uint256 currentFromTimestamp)\n\t\tinternal\n\t\tpure\n\t\treturns (bool)\n\t{\n\t\treturn newToTimestamp < currentFromTimestamp;\n\t}\n\n\tfunction _isFuture(uint256 newFromTimestamp, uint256 currentToTimestamp)\n\t\tinternal\n\t\tpure\n\t\treturns (bool)\n\t{\n\t\treturn currentToTimestamp < newFromTimestamp;\n\t}\n\n\tfunction _checkNowOnSale(string memory spaceMetadata) internal view {\n\t\tfor (uint256 i = 0; i < _periodKeys[spaceMetadata].length; i++) {\n\t\t\tif (!allPeriods[_periodKeys[spaceMetadata][i]].sold) {\n\t\t\t\trevert(\"now on sale\");\n\t\t\t}\n\t\t}\n\t}\n\n\t/// @dev Returns tokenIds tied with the space metadata\n\t/// @param spaceMetadata string of the space metadata\n\tfunction tokenIdsOf(string memory spaceMetadata)\n\t\tpublic\n\t\tview\n\t\treturns (uint256[] memory)\n\t{\n\t\treturn _periodKeys[spaceMetadata];\n\t}\n}\n"
    },
    "contracts/base/SpaceManager.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/NameAccessor.sol\";\nimport \"../peripheries/MediaRegistry.sol\";\nimport \"../peripheries/AdPool.sol\";\nimport \"../peripheries/EventEmitter.sol\";\n\n/// @title SpaceManager - manages ad spaces.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\nabstract contract SpaceManager is NameAccessor {\n\t/// @dev Returns spaceId that is tied with space metadata.\n\tmapping(string => bool) public spaced;\n\n\tfunction _newSpace(string memory spaceMetadata) internal {\n\t\trequire(!spaced[spaceMetadata], \"KD100\");\n\t\tspaced[spaceMetadata] = true;\n\t\t_eventEmitter().emitNewSpace(spaceMetadata);\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _mediaRegistry() internal view returns (MediaRegistry) {\n\t\treturn MediaRegistry(mediaRegistryAddress());\n\t}\n\n\tfunction _adPool() internal view returns (AdPool) {\n\t\treturn AdPool(adPoolAddress());\n\t}\n\n\tfunction _eventEmitter() internal view returns (EventEmitter) {\n\t\treturn EventEmitter(eventEmitterAddress());\n\t}\n}\n"
    },
    "contracts/peripheries/EventEmitter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../accessors/NameAccessor.sol\";\nimport \"../common/BlockTimestamp.sol\";\nimport \"../peripheries/MediaRegistry.sol\";\nimport \"../libraries/Ad.sol\";\n\n/// @title EventEmitter - emits events on behalf of each proxy.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract EventEmitter is NameAccessor, BlockTimestamp {\n\t/// @dev Emitted when a new media is created.\n\tevent NewMedia(\n\t\taddress proxy,\n\t\taddress mediaEOA,\n\t\tstring accountMetadata,\n\t\tuint256 saltNonce\n\t);\n\tevent UpdateMedia(address proxy, address mediaEOA, string accountMetadata);\n\tevent NewSpace(string metadata);\n\tevent DeleteSpace(string metadata);\n\tevent NewPeriod(\n\t\tuint256 tokenId,\n\t\tstring spaceMetadata,\n\t\tstring tokenMetadata,\n\t\tuint256 saleStartTimestamp,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t);\n\tevent DeletePeriod(uint256 tokenId);\n\tevent Buy(uint256 tokenId, uint256 price, address buyer, uint256 timestamp);\n\tevent Bid(uint256 tokenId, uint256 price, address buyer, uint256 timestamp);\n\tevent ReceiveToken(\n\t\tuint256 tokenId,\n\t\tuint256 price,\n\t\taddress buyer,\n\t\tuint256 timestamp\n\t);\n\tevent OfferPeriod(\n\t\tuint256 tokenId,\n\t\tstring spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\taddress sender,\n\t\tuint256 price\n\t);\n\tevent AcceptOffer(\n\t\tuint256 tokenId,\n\t\tstring spaceMetadata,\n\t\tstring tokenMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tuint256 price\n\t);\n\tevent Withdraw(uint256 amount);\n\tevent Propose(uint256 tokenId, string metadata);\n\tevent AcceptProposal(uint256 tokenId, string metadata);\n\tevent DenyProposal(uint256 tokenId, string metadata, string reason);\n\tevent TransferCustom(\n\t\taddress indexed from,\n\t\taddress indexed to,\n\t\tuint256 indexed tokenId\n\t);\n\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\tmodifier onlyProxies() {\n\t\trequire(_mediaRegistry().ownerOf(msg.sender) != address(0x0), \"KD011\");\n\t\t_;\n\t}\n\n\tfunction emitNewSpace(string memory metadata) external onlyProxies {\n\t\temit NewSpace(metadata);\n\t}\n\n\tfunction emitDeleteSpace(string memory metadata) external onlyProxies {\n\t\temit DeleteSpace(metadata);\n\t}\n\n\tfunction emitNewPeriod(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 saleStartTimestamp,\n\t\tuint256 saleEndTimestamp,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tAd.Pricing pricing,\n\t\tuint256 minPrice\n\t) external onlyProxies {\n\t\temit NewPeriod(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\tsaleStartTimestamp,\n\t\t\tsaleEndTimestamp,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tpricing,\n\t\t\tminPrice\n\t\t);\n\t}\n\n\tfunction emitDeletePeriod(uint256 tokenId) external onlyProxies {\n\t\temit DeletePeriod(tokenId);\n\t}\n\n\tfunction emitBuy(\n\t\tuint256 tokenId,\n\t\tuint256 msgValue,\n\t\taddress msgSender\n\t) external onlyProxies {\n\t\temit Buy(tokenId, msgValue, msgSender, _blockTimestamp());\n\t}\n\n\tfunction emitBid(\n\t\tuint256 tokenId,\n\t\tuint256 msgValue,\n\t\taddress msgSender\n\t) external onlyProxies {\n\t\temit Bid(tokenId, msgValue, msgSender, _blockTimestamp());\n\t}\n\n\tfunction emitReceiveToken(\n\t\tuint256 tokenId,\n\t\tuint256 price,\n\t\taddress buyer\n\t) external onlyProxies {\n\t\temit ReceiveToken(tokenId, price, buyer, _blockTimestamp());\n\t}\n\n\tfunction emitOfferPeriod(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\taddress sender,\n\t\tuint256 price\n\t) external onlyProxies {\n\t\temit OfferPeriod(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tsender,\n\t\t\tprice\n\t\t);\n\t}\n\n\tfunction emitAcceptOffer(\n\t\tuint256 tokenId,\n\t\tstring memory spaceMetadata,\n\t\tstring memory tokenMetadata,\n\t\tuint256 displayStartTimestamp,\n\t\tuint256 displayEndTimestamp,\n\t\tuint256 price\n\t) external onlyProxies {\n\t\temit AcceptOffer(\n\t\t\ttokenId,\n\t\t\tspaceMetadata,\n\t\t\ttokenMetadata,\n\t\t\tdisplayStartTimestamp,\n\t\t\tdisplayEndTimestamp,\n\t\t\tprice\n\t\t);\n\t}\n\n\tfunction emitWithdraw(uint256 amount) external onlyProxies {\n\t\temit Withdraw(amount);\n\t}\n\n\tfunction emitPropose(uint256 tokenId, string memory metadata)\n\t\texternal\n\t\tonlyProxies\n\t{\n\t\temit Propose(tokenId, metadata);\n\t}\n\n\tfunction emitAcceptProposal(uint256 tokenId, string memory metadata)\n\t\texternal\n\t\tonlyProxies\n\t{\n\t\temit AcceptProposal(tokenId, metadata);\n\t}\n\n\tfunction emitDenyProposal(\n\t\tuint256 tokenId,\n\t\tstring memory metadata,\n\t\tstring memory reason\n\t) external onlyProxies {\n\t\temit DenyProposal(tokenId, metadata, reason);\n\t}\n\n\tfunction emitTransferCustom(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 tokenId\n\t) external onlyProxies {\n\t\temit TransferCustom(from, to, tokenId);\n\t}\n\n\tfunction emitNewMedia(\n\t\taddress proxy,\n\t\taddress mediaEOA,\n\t\tstring memory accountMetadata,\n\t\tuint256 saltNonce\n\t) external onlyFactory {\n\t\temit NewMedia(proxy, mediaEOA, accountMetadata, saltNonce);\n\t}\n\n\tfunction emitUpdateMedia(\n\t\taddress proxy,\n\t\taddress mediaEOA,\n\t\tstring memory accountMetadata\n\t) external onlyProxies {\n\t\temit UpdateMedia(proxy, mediaEOA, accountMetadata);\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _mediaRegistry() internal view returns (MediaRegistry) {\n\t\treturn MediaRegistry(mediaRegistryAddress());\n\t}\n}\n"
    },
    "contracts/proxies/MediaFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"../proxies/MediaProxy.sol\";\nimport \"../accessors/NameAccessor.sol\";\nimport \"../peripheries/EventEmitter.sol\";\nimport \"../peripheries/MediaRegistry.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title MediaFactory - creates proxy contracts for media accounts.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract MediaFactory is NameAccessor {\n\t/// @dev Emitted when a new media is created.\n\tevent CreateProxy(MediaProxy proxy);\n\n\t/// @dev Initializer\n\t/// @param _nameRegistry address of NameRegistry\n\tconstructor(address _nameRegistry) {\n\t\tinitialize(_nameRegistry);\n\t}\n\n\t/// @dev Create a new account for media. Each proxy has its own storage and saves\n\t///      data related to NFTs.\n\t/// @param mediaEOA address of the media EOA\n\t/// @param accountMetadata string of metadata for the defailts of the account\n\t/// @param initializer bytes of the initalize calldata\n\t/// @param saltNonce uint256 of the salt number to create a proxy address\n\tfunction newMedia(\n\t\taddress mediaEOA,\n\t\tstring memory accountMetadata,\n\t\tbytes memory initializer,\n\t\tuint256 saltNonce\n\t) external onlyOwner returns (MediaProxy proxy) {\n\t\tproxy = createProxyWithNonce(nameRegistryAddress(), initializer, saltNonce);\n\t\t_registry().addMedia(address(proxy), accountMetadata, mediaEOA);\n\t\t_event().emitNewMedia(address(proxy), mediaEOA, accountMetadata, saltNonce);\n\t}\n\n\t/// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n\t/// @param accessor Address of accessor contract.\n\t/// @param initializer Payload for message call sent to new proxy contract.\n\t/// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n\tfunction createProxyWithNonce(\n\t\taddress accessor,\n\t\tbytes memory initializer,\n\t\tuint256 saltNonce\n\t) internal returns (MediaProxy proxy) {\n\t\tproxy = deployProxyWithNonce(accessor, initializer, saltNonce);\n\t\tif (initializer.length > 0)\n\t\t\t// solhint-disable-next-line no-inline-assembly\n\t\t\tassembly {\n\t\t\t\tif eq(\n\t\t\t\t\tcall(\n\t\t\t\t\t\tgas(),\n\t\t\t\t\t\tproxy,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\tadd(initializer, 0x20),\n\t\t\t\t\t\tmload(initializer),\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0\n\t\t\t\t\t),\n\t\t\t\t\t0\n\t\t\t\t) {\n\t\t\t\t\trevert(0, 0)\n\t\t\t\t}\n\t\t\t}\n\t\temit CreateProxy(proxy);\n\t}\n\n\t/// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n\t///      This method is only meant as an utility to be called from other methods\n\t/// @param accessor Address of accessor contract.\n\t/// @param initializer Payload for message call sent to new proxy contract.\n\t/// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n\tfunction deployProxyWithNonce(\n\t\taddress accessor,\n\t\tbytes memory initializer,\n\t\tuint256 saltNonce\n\t) internal returns (MediaProxy proxy) {\n\t\t// If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n\t\tbytes32 salt = keccak256(\n\t\t\tabi.encodePacked(keccak256(initializer), saltNonce)\n\t\t);\n\t\tbytes memory deploymentData = abi.encodePacked(\n\t\t\ttype(MediaProxy).creationCode,\n\t\t\tuint256(uint160(accessor))\n\t\t);\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tproxy := create2(\n\t\t\t\t0x0,\n\t\t\t\tadd(0x20, deploymentData),\n\t\t\t\tmload(deploymentData),\n\t\t\t\tsalt\n\t\t\t)\n\t\t}\n\t\trequire(address(proxy) != address(0), \"Create2 call failed\");\n\t}\n\n\t/**\n\t * Accessors\n\t */\n\tfunction _registry() internal view returns (MediaRegistry) {\n\t\treturn MediaRegistry(mediaRegistryAddress());\n\t}\n\n\tfunction _event() internal view returns (EventEmitter) {\n\t\treturn EventEmitter(eventEmitterAddress());\n\t}\n}\n"
    },
    "contracts/proxies/MediaProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./IProxy.sol\";\nimport \"../accessors/NameRegistry.sol\";\n\n/// @title MediaProxy - do delegatecalls to the destination contract.\n/// @author Shumpei Koike - <shumpei.koike@bridges.inc>\ncontract MediaProxy is IProxy {\n\tNameRegistry internal _nameRegistry;\n\n\t/// @dev Initializer\n\t/// @param nameRegistry address of NameRegistry\n\tconstructor(address nameRegistry) {\n\t\trequire(nameRegistry != address(0), \"AR001\");\n\t\t_nameRegistry = NameRegistry(nameRegistry);\n\t}\n\n\t/// @dev Returns the address of the destination contract\n\tfunction masterCopy() public view returns (address) {\n\t\treturn _nameRegistry.get(keccak256(abi.encodePacked(\"MediaFacade\")));\n\t}\n\n\t/// @dev Calls logic on the destination contract.\n\t///      The desitination is decided by NameRegistry, which can be switched by the administrator\n\t///      if the contract has any changes.\n\tfallback() external payable {\n\t\t_fallback();\n\t}\n\n\tfunction _fallback() internal {\n\t\taddress _singleton = masterCopy();\n\t\t// solhint-disable-next-line no-inline-assembly\n\t\tassembly {\n\t\t\tif eq(\n\t\t\t\tcalldataload(0),\n\t\t\t\t0xa619486e00000000000000000000000000000000000000000000000000000000\n\t\t\t) {\n\t\t\t\tmstore(0, _singleton)\n\t\t\t\treturn(0, 0x20)\n\t\t\t}\n\t\t\tcalldatacopy(0, 0, calldatasize())\n\t\t\tlet success := delegatecall(gas(), _singleton, 0, calldatasize(), 0, 0)\n\t\t\treturndatacopy(0, 0, returndatasize())\n\t\t\tswitch success\n\t\t\tcase 0 {\n\t\t\t\trevert(0, returndatasize())\n\t\t\t}\n\t\t\tdefault {\n\t\t\t\treturn(0, returndatasize())\n\t\t\t}\n\t\t}\n\t}\n\n\t/// @dev Transfers fees to Vault when receiving Ether payments.\n\treceive() external payable {\n\t\trequire(msg.value != 0, \"msg.value is zero\");\n\t\taddress vault = _nameRegistry.get(keccak256(abi.encodePacked(\"Vault\")));\n\t\tpayable(vault).transfer(msg.value / 2);\n\t}\n}\n"
    },
    "contracts/proxies/IProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\n/// @title IProxy - Helper interface to access masterCopy of the Proxy on-chain\ninterface IProxy {\n\tfunction masterCopy() external view returns (address);\n}\n"
    },
    "contracts/common/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n\t/**\n\t * @dev See {IERC165-supportsInterface}.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn interfaceId == type(IERC165).interfaceId;\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
